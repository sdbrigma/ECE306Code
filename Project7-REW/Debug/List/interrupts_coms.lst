###############################################################################
#
# IAR C/C++ Compiler V6.30.2.940/W32 for MSP430           06/Nov/2015  13:23:40
# Copyright 1996-2015 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for Texas Instruments MSP430, 8K KickStart Edition 6.30
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  C:\Users\Rachel\Documents\ECE306\HW\HW9\interrupts_coms.c
#    Command line  =  
#        C:\Users\Rachel\Documents\ECE306\HW\HW9\interrupts_coms.c -lC
#        C:\Users\Rachel\Documents\ECE306\HW\HW9\Debug\List\ -o
#        C:\Users\Rachel\Documents\ECE306\HW\HW9\Debug\Obj\ --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --debug
#        -D__MSP430FR5739__ -e --double=32 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.2_2\430\lib\dlib\dl430xlsfn.h"
#        --core=430X --data_model=small -On --multiplier=32
#        --hw_workaround=CPU40 --code_model=large
#    List file     =  
#        C:\Users\Rachel\Documents\ECE306\HW\HW9\Debug\List\interrupts_coms.lst
#    Object file   =  
#        C:\Users\Rachel\Documents\ECE306\HW\HW9\Debug\Obj\interrupts_coms.r43
#
###############################################################################

C:\Users\Rachel\Documents\ECE306\HW\HW9\interrupts_coms.c
      1          //*****************************************************************************
      2          //      Title: interrupts_coms
      3          //      Description: Handles interrupts for TX and RX communication
      4          //      Rachel Williams
      5          //      October 2015
      6          //      Built with IAR Embedded Workbench Version: V4.10A/W32 (5.40.1)
      7          //*****************************************************************************
      8          
      9          #include  "msp430.h"

   \                                 In  segment DATA16_AN, at 0x5ec
   \   union <unnamed> _A_UCA1RXBUF_L
   \                     _A_UCA1RXBUF_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x5fe
   \   unsigned short volatile UCA1IV
   \                     UCA1IV:
   \   000000                DS8 2
     10          #include  "functions.h"
     11          #include  "macros.h"
     12          
     13          //*****************************************************************************
     14          //      Function name: USCI_A0_ISR
     15          //      Description: Transmission and reception interrupt for USCI_A
     16          //      Global variables: 
     17          //      Local variables: temp
     18          //      Return: VOID
     19          //*****************************************************************************
     20          
     21          #pragma vector=USCI_A1_VECTOR

   \                                 In  segment ISR_CODE, align 2
     22          __interrupt void USCI_A1_ISR(void){
   \                     USCI_A1_ISR:
   \   000000   1F15         PUSHM.W #0x2, R15
     23            switch(__even_in_range(UCA1IV,UCA1IV_DFLT)){
   \   000002   1F42FE05     MOV.W   &0x5fe, R15
   \   000006   E00F         ADDA    R15, PC
   \                     `?<Jumptable for USCI_A1_ISR>_0`:
   \   000008   173C         JMP     ??USCI_A1_ISR_2
   \   00000A   033C         JMP     ??USCI_A1_ISR_3
   \   00000C   153C         JMP     ??USCI_A1_ISR_2
   \   00000E   143C         JMP     ??USCI_A1_ISR_2
   \   000010   133C         JMP     ??USCI_A1_ISR_2
     24            case POSIT_0:                               // Vector 0 - no interrupt
     25              break;
     26            case POSIT_2:                               // Vector 2 - RXIFG
     27              enabled_RX = POSIT_1; 
   \                     ??USCI_A1_ISR_3:
   \   000012   D243....     MOV.B   #0x1, &enabled_RX
     28              temp = cpu_rx_ring_wr; 
   \   000016   9242........ MOV.W   &cpu_rx_ring_wr, &temp
     29              temp1 = UCA1RXBUF;                       // RX -> USB_Char_Rx character
   \   00001C   1E42EC05     MOV.W   &0x5ec, R14
   \   000020   C24E....     MOV.B   R14, &temp1
     30              if (++cpu_rx_ring_wr >= (SMALL_RING_SIZE)){
   \   000024   1F42....     MOV.W   &cpu_rx_ring_wr, R15
   \   000028   1F53         ADD.W   #0x1, R15
   \   00002A   824F....     MOV.W   R15, &cpu_rx_ring_wr
   \   00002E   3F901000     CMP.W   #0x10, R15
   \   000032   0228         JNC     ??USCI_A1_ISR_2
     31                cpu_rx_ring_wr = BEGINNING;           // Circular buffer back to beginning
   \   000034   8243....     MOV.W   #0x0, &cpu_rx_ring_wr
     32              }
     33              break;
     34            case POSIT_4:                               // Vector 4 – TXIFG
     35              break;
     36            default: break;
     37            }
     38          }
   \                     ??USCI_A1_ISR_2:
   \   000038   1E17         POPM.W  #0x2, R15
   \   00003A   0013         RETI
   \   00003C                REQUIRE _A_UCA1RXBUF_L
   \   00003C                REQUIRE UCA1IV

   \                                 In  segment INTVEC, offset 0x56, root
   \                     `??USCI_A1_ISR::??INTVEC 86`:
   \   000056   ....         DC16    USCI_A1_ISR

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      8   USCI_A1_ISR


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       2  UCA1IV
      60  USCI_A1_ISR
       2  USCI_A1_ISR::??INTVEC 86
       2  _A_UCA1RXBUF_L

 
  4 bytes in segment DATA16_AN
  2 bytes in segment INTVEC
 60 bytes in segment ISR_CODE
 
 60 bytes of CODE  memory
  0 bytes of CONST memory (+ 2 bytes shared)
  0 bytes of DATA  memory (+ 4 bytes shared)

Errors: none
Warnings: none
