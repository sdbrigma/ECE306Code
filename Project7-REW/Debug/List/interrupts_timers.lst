###############################################################################
#
# IAR C/C++ Compiler V6.30.2.940/W32 for MSP430           06/Nov/2015  13:23:40
# Copyright 1996-2015 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for Texas Instruments MSP430, 8K KickStart Edition 6.30
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  
#        C:\Users\Rachel\Documents\ECE306\HW\HW9\interrupts_timers.c
#    Command line  =  
#        C:\Users\Rachel\Documents\ECE306\HW\HW9\interrupts_timers.c -lC
#        C:\Users\Rachel\Documents\ECE306\HW\HW9\Debug\List\ -o
#        C:\Users\Rachel\Documents\ECE306\HW\HW9\Debug\Obj\ --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --debug
#        -D__MSP430FR5739__ -e --double=32 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.2_2\430\lib\dlib\dl430xlsfn.h"
#        --core=430X --data_model=small -On --multiplier=32
#        --hw_workaround=CPU40 --code_model=large
#    List file     =  
#        C:\Users\Rachel\Documents\ECE306\HW\HW9\Debug\List\interrupts_timers.lst
#    Object file   =  
#        C:\Users\Rachel\Documents\ECE306\HW\HW9\Debug\Obj\interrupts_timers.r43
#
###############################################################################

C:\Users\Rachel\Documents\ECE306\HW\HW9\interrupts_timers.c
      1          //***********************************************************************
      2          //      Title: interrupts_timers.c 
      3          //      Description: This file initializes and configures all interrupts
      4          //      Rachel Williams
      5          //      October 2015
      6          //      Built with IAR Embedded Workbench Version: V4.10A/W32 (5.40.1)
      7          //***********************************************************************
      8          
      9          #include  "msp430.h"

   \                                 In  segment DATA16_AN, at 0x322
   \   union <unnamed> _A_PJOUT_L
   \                     _A_PJOUT_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x340
   \   unsigned short volatile TA0CTL
   \                     TA0CTL:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x342
   \   unsigned short volatile TA0CCTL0
   \                     TA0CCTL0:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x352
   \   unsigned short volatile TA0CCR0
   \                     TA0CCR0:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x360
   \   unsigned short volatile TA0EX0
   \                     TA0EX0:
   \   000000                DS8 2
     10          #include  "functions.h"
     11          #include "macros.h"
     12          
     13          //***********************************************************************
     14          //      Function name: Init_Timer_A0
     15          //      Description: Initializes Timer A0, sets up both A0_0 and A0_1-A0_2 
     16          //***********************************************************************

   \                                 In  segment CODE, align 2
     17          void Init_Timer_A0(void) {
   \                     Init_Timer_A0:
     18           TA0CTL = TASSEL__SMCLK;    // SMCLK source
   \   000000   B24000024003 MOV.W   #0x200, &0x340
     19           TA0CTL |= TACLR;           // Resets TA0R, clock divider, count direction
   \   000006   A2D24003     BIS.W   #0x4, &0x340
     20           TA0CTL |= MC__CONTINOUS;   // Continuous up to 0xFFFH then back to 0
   \   00000A   B2D020004003 BIS.W   #0x20, &0x340
     21           TA0CTL |= ID__2;           // Divide clock by 2
   \   000010   B2D040004003 BIS.W   #0x40, &0x340
     22           TA0CTL &= ~TAIE;           // Disable Overflow Interrupt
   \   000016   A2C34003     BIC.W   #0x2, &0x340
     23           TA0CTL &= ~TAIFG;          // Clear Overflow Interrupt flag
   \   00001A   92C34003     BIC.W   #0x1, &0x340
     24           
     25           TA0EX0 = TAIDEX_7;         // Divide clock by an additional 8, index bit
   \   00001E   B24007006003 MOV.W   #0x7, &0x360
     26          
     27           TA0CCR0 = TA0CCR0_INTERVAL; // CCR0, time the timer counts up to 
   \   000024   B240A8615203 MOV.W   #0x61a8, &0x352
     28           TA0CCTL0 |= CCIE;           // CCR0 enable interrupt, as soon as it's 
   \   00002A   B2D010004203 BIS.W   #0x10, &0x342
     29                                       //      initialized, interrupts will come in 
     30          }
   \   000030   1001         RETA
   \   000032                REQUIRE TA0CTL
   \   000032                REQUIRE TA0EX0
   \   000032                REQUIRE TA0CCR0
   \   000032                REQUIRE TA0CCTL0
     31          
     32          #pragma vector = TIMER0_A0_VECTOR 

   \                                 In  segment ISR_CODE, align 2
     33          __interrupt void Timer0_A0_ISR(void){  
   \                     Timer0_A0_ISR:
     34            if(milli_counter > MAX_MILLI){
   \   000000   F2901600.... CMP.B   #0x16, &milli_counter
   \   000006   0228         JNC     ??Timer0_A0_ISR_0
     35              milli_counter = ORIGINAL;
   \   000008   C243....     MOV.B   #0x0, &milli_counter
     36            }
     37            
     38            if(milli_counter == ONE_SECOND){
   \                     ??Timer0_A0_ISR_0:
   \   00000C   F2901400.... CMP.B   #0x14, &milli_counter
   \   000012   0620         JNE     ??Timer0_A0_ISR_1
     39               milli_counter2++; 
   \   000014   D253....     ADD.B   #0x1, &milli_counter2
     40               PJOUT ^= LED3; 
   \   000018   A2E22203     XOR.W   #0x4, &0x322
     41               milli_counter= ORIGINAL;
   \   00001C   C243....     MOV.B   #0x0, &milli_counter
     42            }
     43            milli_counter++;
   \                     ??Timer0_A0_ISR_1:
   \   000020   D253....     ADD.B   #0x1, &milli_counter
     44            TA0CCR0 += TA0CCR0_INTERVAL; // Add Offset to TACCR0, get new interrupt
   \   000024   B250A8615203 ADD.W   #0x61a8, &0x352
     45                                         // same # of counts b/w interrupts 
     46          }
   \   00002A   0013         RETI
   \   00002C                REQUIRE _A_PJOUT_L
   \   00002C                REQUIRE TA0CCR0

   \                                 In  segment INTVEC, offset 0x5a, root
   \                     `??Timer0_A0_ISR::??INTVEC 90`:
   \   00005A   ....         DC16    Timer0_A0_ISR

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      4   Init_Timer_A0
      4   Timer0_A0_ISR


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      50  Init_Timer_A0
       2  TA0CCR0
       2  TA0CCTL0
       2  TA0CTL
       2  TA0EX0
      44  Timer0_A0_ISR
       2  Timer0_A0_ISR::??INTVEC 90
       2  _A_PJOUT_L

 
 50 bytes in segment CODE
 10 bytes in segment DATA16_AN
  2 bytes in segment INTVEC
 44 bytes in segment ISR_CODE
 
 94 bytes of CODE  memory
  0 bytes of CONST memory (+  2 bytes shared)
  0 bytes of DATA  memory (+ 10 bytes shared)

Errors: none
Warnings: none
