###############################################################################
#
# IAR C/C++ Compiler V6.30.2.940/W32 for MSP430           02/Nov/2015  17:46:52
# Copyright 1996-2015 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for Texas Instruments MSP430, 8K KickStart Edition 6.30
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  
#        C:\Users\Rachel\Documents\ECE306\Projects\Project6\Project6_Demo.c
#    Command line  =  
#        C:\Users\Rachel\Documents\ECE306\Projects\Project6\Project6_Demo.c -lC
#        C:\Users\Rachel\Documents\ECE306\Projects\Project6\Debug\List\ -o
#        C:\Users\Rachel\Documents\ECE306\Projects\Project6\Debug\Obj\ --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --debug
#        -D__MSP430FR5739__ -e --double=32 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.2_2\430\lib\dlib\dl430xlsfn.h"
#        --core=430X --data_model=small -On --multiplier=32
#        --hw_workaround=CPU40 --code_model=large
#    List file     =  
#        C:\Users\Rachel\Documents\ECE306\Projects\Project6\Debug\List\Project6_Demo.lst
#    Object file   =  
#        C:\Users\Rachel\Documents\ECE306\Projects\Project6\Debug\Obj\Project6_Demo.r43
#
###############################################################################

C:\Users\Rachel\Documents\ECE306\Projects\Project6\Project6_Demo.c
      1          //***********************************************************************
      2          //      Title: Project6_Demo.c 
      3          //      Description: This file handles demonstration for Project 6  
      4          //      Rachel Williams
      5          //      November 2015
      6          //      Built with IAR Embedded Workbench Version: V4.10A/W32 (5.40.1)
      7          //***********************************************************************
      8          #include  "msp430.h"

   \                                 In  segment DATA16_AN, at 0x220
   \   union <unnamed> _A_PBIN_L
   \                     _A_PBIN_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x5ec
   \   union <unnamed> _A_UCA1RXBUF_L
   \                     _A_UCA1RXBUF_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x5ee
   \   union <unnamed> _A_UCA1TXBUF_L
   \                     _A_UCA1TXBUF_L:
   \   000000                DS8 2
      9          #include  "functions.h"
     10          #include  "macros.h"
     11          
     12          //***********************************************************************
     13          //      Function name: P6Demo
     14          //      Description: This file contains code for project 6 demo 
     15          //      Global variables: 
     16          //      Local variables: 
     17          //      Return: VOID
     18          //***********************************************************************

   \                                 In  segment CODE, align 2
     19          void P6Demo(void){ 
   \                     P6Demo:
   \                     ??P6Demo_0:
     20            
     21            //while(enabled_RX){
     22            while(ALWAYS){  
     23              // Always calls the conversion function 
     24              //Convert_H2I(); 
     25              Passing();
   \   000000   ........     CALLA   #Passing
   \   000004   FD3F         JMP     ??P6Demo_0
   \   000006   0343         NOP
     26              //Counting(); 
     27            }
     28          }
     29          
     30          //***********************************************************************
     31          //      Function name: Passing
     32          //      Description: This file contains code for project 6 demo 
     33          //      Global variables: 
     34          //      Local variables: 
     35          //      Return: VOID
     36          //***********************************************************************

   \                                 In  segment CODE, align 2
     37          void Passing(void){
   \                     Passing:
   \   000000   0A12         PUSH.W  R10
     38            diff = ORIGINAL;
   \   000002   8243....     MOV.W   #0x0, &diff
     39            
     40            // establishing reset protocol utilizing tilde symbol 
     41            if (!(P4IN & SW1)){
   \   000006   D2B32102     BIT.B   #0x1, &0x221
   \   00000A   682C         JC      ??Passing_1
     42              
     43              // transmitting tilde 
     44              UCA1TXBUF = TILDE;
   \   00000C   B2407E00EE05 MOV.W   #0x7e, &0x5ee
     45              
     46              // delay after transmission 
     47              Five_Msec_Delay(POSIT_5);
   \   000012   3C400500     MOV.W   #0x5, R12
   \   000016   ........     CALLA   #Five_Msec_Delay
     48              
     49              // reinitializing transmission buffer to 0x0030 ('0') 
     50              //UCA1TXBUF = NUM_BASE;
     51              
     52              // reinitializing other variables for reset 
     53              diff = ORIGINAL + NUM_BASE; 
   \   00001A   B2403000.... MOV.W   #0x30, &diff
     54              i = NUM_BASE; 
   \   000020   F2403000.... MOV.B   #0x30, &i
     55              j = NUM_BASE; 
   \   000026   F2403000.... MOV.B   #0x30, &j
     56              
     57              // updating character array after reset 
     58              Char_Array[POSIT_0] = NUM_BASE;
   \   00002C   F2403000.... MOV.B   #0x30, &Char_Array
     59              Char_Array[POSIT_1] = j;
   \   000032   D242........ MOV.B   &j, &Char_Array + 1
     60              Char_Array[POSIT_2] = i; 
   \   000038   D242........ MOV.B   &i, &Char_Array + 2
     61              Char_Array[POSIT_3] = diff;
   \   00003E   D242........ MOV.B   &diff, &Char_Array + 3
     62              
     63              // updating display 
     64              display_1[POSIT_0] = NUM_BASE;
   \   000044   1F42....     MOV.W   &display_1, R15
   \   000048   FF4030000000 MOV.B   #0x30, 0(R15)
     65              display_1[POSIT_1] = NUM_BASE;
   \   00004E   1F42....     MOV.W   &display_1, R15
   \   000052   FF4030000100 MOV.B   #0x30, 0x1(R15)
     66              display_1[POSIT_2] = NUM_BASE;
   \   000058   1F42....     MOV.W   &display_1, R15
   \   00005C   FF4030000200 MOV.B   #0x30, 0x2(R15)
     67              display_1[POSIT_3] = NUM_BASE;
   \   000062   1F42....     MOV.W   &display_1, R15
   \   000066   FF4030000300 MOV.B   #0x30, 0x3(R15)
     68              display_1[POSIT_4] = NUM_BASE;
   \   00006C   1F42....     MOV.W   &display_1, R15
   \   000070   FF4030000400 MOV.B   #0x30, 0x4(R15)
     69              display_1[POSIT_5] = NUM_BASE;
   \   000076   1F42....     MOV.W   &display_1, R15
   \   00007A   FF4030000500 MOV.B   #0x30, 0x5(R15)
     70              display_1[POSIT_6] = NUM_BASE;
   \   000080   1F42....     MOV.W   &display_1, R15
   \   000084   FF4030000600 MOV.B   #0x30, 0x6(R15)
     71              display_1[POSIT_7] = NUM_BASE;
   \   00008A   1F42....     MOV.W   &display_1, R15
   \   00008E   FF4030000700 MOV.B   #0x30, 0x7(R15)
     72              display_1[POSIT_8] = NUM_BASE;
   \   000094   1F42....     MOV.W   &display_1, R15
   \   000098   FF4030000800 MOV.B   #0x30, 0x8(R15)
     73              display_1[POSIT_9] = NUM_BASE;
   \   00009E   1F42....     MOV.W   &display_1, R15
   \   0000A2   FF4030000900 MOV.B   #0x30, 0x9(R15)
     74              Display_Process(); 
   \   0000A8   ........     CALLA   #Display_Process
     75              
     76              // reinitializing transmission buffer to 0x0030 ('0') 
     77              UCA1TXBUF = Char_Array[POSIT_0]; 
   \   0000AC   5F42....     MOV.B   &Char_Array, R15
   \   0000B0   4F4F         MOV.B   R15, R15
   \   0000B2   824FEE05     MOV.W   R15, &0x5ee
     78              //Five_Msec_Delay(POSIT_2);
     79              UCA1TXBUF = Char_Array[POSIT_1];
   \   0000B6   5F42....     MOV.B   &Char_Array + 1, R15
   \   0000BA   4F4F         MOV.B   R15, R15
   \   0000BC   824FEE05     MOV.W   R15, &0x5ee
     80              //Five_Msec_Delay(POSIT_2);
     81              UCA1TXBUF = Char_Array[POSIT_2];
   \   0000C0   5F42....     MOV.B   &Char_Array + 2, R15
   \   0000C4   4F4F         MOV.B   R15, R15
   \   0000C6   824FEE05     MOV.W   R15, &0x5ee
     82              //Five_Msec_Delay(POSIT_2);
     83              UCA1TXBUF = Char_Array[POSIT_3];
   \   0000CA   5F42....     MOV.B   &Char_Array + 3, R15
   \   0000CE   4F4F         MOV.B   R15, R15
   \   0000D0   824FEE05     MOV.W   R15, &0x5ee
     84              //Five_Msec_Delay(POSIT_2);
     85              
     86              // delay after reset
     87              Five_Msec_Delay(POSIT_5);
   \   0000D4   3C400500     MOV.W   #0x5, R12
   \   0000D8   ........     CALLA   #Five_Msec_Delay
     88            }
     89            
     90            // taking value from buffer: in hex format 
     91            for(int index=ORIGINAL; index < POSIT_4; index++){
   \                     ??Passing_1:
   \   0000DC   0A43         MOV.W   #0x0, R10
   \                     ??Passing_0:
   \   0000DE   2A92         CMP.W   #0x4, R10
   \   0000E0   0934         JGE     ??Passing_2
     92              Char_Array[index] = UCA1RXBUF;
   \   0000E2   1E42EC05     MOV.W   &0x5ec, R14
   \   0000E6   CA4E....     MOV.B   R14, Char_Array(R10)
     93              Five_Msec_Delay(POSIT_2);
   \   0000EA   2C43         MOV.W   #0x2, R12
   \   0000EC   ........     CALLA   #Five_Msec_Delay
     94            }
   \   0000F0   1A53         ADD.W   #0x1, R10
   \   0000F2   F53F         JMP     ??Passing_0
     95            
     96             // handling when tilde is received 
     97            if(Char_Array[POSIT_3] == TILDE){
   \                     ??Passing_2:
   \   0000F4   F2907E00.... CMP.B   #0x7e, &Char_Array + 3
   \   0000FA   4A20         JNE     ??Passing_3
     98              
     99              // reset everything  
    100              diff = ORIGINAL + NUM_BASE; 
   \   0000FC   B2403000.... MOV.W   #0x30, &diff
    101              i = NUM_BASE; 
   \   000102   F2403000.... MOV.B   #0x30, &i
    102              j = NUM_BASE; 
   \   000108   F2403000.... MOV.B   #0x30, &j
    103              Char_Array[POSIT_0] = NUM_BASE;
   \   00010E   F2403000.... MOV.B   #0x30, &Char_Array
    104              Char_Array[POSIT_1] = j;
   \   000114   D242........ MOV.B   &j, &Char_Array + 1
    105              Char_Array[POSIT_2] = i; 
   \   00011A   D242........ MOV.B   &i, &Char_Array + 2
    106              Char_Array[POSIT_3] = diff;
   \   000120   D242........ MOV.B   &diff, &Char_Array + 3
    107              
    108              // updating display 
    109              display_1[POSIT_0] = NUM_BASE;
   \   000126   1F42....     MOV.W   &display_1, R15
   \   00012A   FF4030000000 MOV.B   #0x30, 0(R15)
    110              display_1[POSIT_1] = NUM_BASE;
   \   000130   1F42....     MOV.W   &display_1, R15
   \   000134   FF4030000100 MOV.B   #0x30, 0x1(R15)
    111              display_1[POSIT_2] = NUM_BASE;
   \   00013A   1F42....     MOV.W   &display_1, R15
   \   00013E   FF4030000200 MOV.B   #0x30, 0x2(R15)
    112              display_1[POSIT_3] = NUM_BASE;
   \   000144   1F42....     MOV.W   &display_1, R15
   \   000148   FF4030000300 MOV.B   #0x30, 0x3(R15)
    113              display_1[POSIT_4] = NUM_BASE;
   \   00014E   1F42....     MOV.W   &display_1, R15
   \   000152   FF4030000400 MOV.B   #0x30, 0x4(R15)
    114              display_1[POSIT_5] = NUM_BASE;
   \   000158   1F42....     MOV.W   &display_1, R15
   \   00015C   FF4030000500 MOV.B   #0x30, 0x5(R15)
    115              display_1[POSIT_6] = NUM_BASE;
   \   000162   1F42....     MOV.W   &display_1, R15
   \   000166   FF4030000600 MOV.B   #0x30, 0x6(R15)
    116              display_1[POSIT_7] = NUM_BASE;
   \   00016C   1F42....     MOV.W   &display_1, R15
   \   000170   FF4030000700 MOV.B   #0x30, 0x7(R15)
    117              display_1[POSIT_8] = NUM_BASE;
   \   000176   1F42....     MOV.W   &display_1, R15
   \   00017A   FF4030000800 MOV.B   #0x30, 0x8(R15)
    118              display_1[POSIT_9] = NUM_BASE;
   \   000180   1F42....     MOV.W   &display_1, R15
   \   000184   FF4030000900 MOV.B   #0x30, 0x9(R15)
    119              Display_Process();  
   \   00018A   ........     CALLA   #Display_Process
   \   00018E   993C         JMP     ??Passing_4
    120            } else{
    121              // conversion: hex to int 
    122              diff = Char_Array[POSIT_3] - NUM_BASE; 
   \                     ??Passing_3:
   \   000190   5F42....     MOV.B   &Char_Array + 3, R15
   \   000194   4F4F         MOV.B   R15, R15
   \   000196   3F50D0FF     ADD.W   #0xffd0, R15
   \   00019A   824F....     MOV.W   R15, &diff
    123              
    124              // handling condition: when diff < 9, add one 
    125              if(diff < POSIT_9){
   \   00019E   B2900900.... CMP.W   #0x9, &diff
   \   0001A4   0334         JGE     ??Passing_5
    126                diff++; 
   \   0001A6   9253....     ADD.W   #0x1, &diff
   \   0001AA   083C         JMP     ??Passing_6
    127              }else if(diff == POSIT_9){
   \                     ??Passing_5:
   \   0001AC   B2900900.... CMP.W   #0x9, &diff
   \   0001B2   0420         JNE     ??Passing_6
    128                diff = ORIGINAL;
   \   0001B4   8243....     MOV.W   #0x0, &diff
    129                i++; // updating tens place
   \   0001B8   D253....     ADD.B   #0x1, &i
    130              }
    131              
    132              // when tens place has reached 9, hundreds place is incremented 
    133              if(i > NUM_9){
   \                     ??Passing_6:
   \   0001BC   F2903A00.... CMP.B   #0x3a, &i
   \   0001C2   0528         JNC     ??Passing_7
    134                i = NUM_BASE;
   \   0001C4   F2403000.... MOV.B   #0x30, &i
    135                j++; 
   \   0001CA   D253....     ADD.B   #0x1, &j
    136              }
    137              
    138              // when hundreds place has reached 9, resets back to zero 
    139              if(j > NUM_9){
   \                     ??Passing_7:
   \   0001CE   F2903A00.... CMP.B   #0x3a, &j
   \   0001D4   0628         JNC     ??Passing_8
    140                i = NUM_BASE; 
   \   0001D6   F2403000.... MOV.B   #0x30, &i
    141                j = NUM_BASE;
   \   0001DC   F2403000.... MOV.B   #0x30, &j
    142              }
    143              
    144              // conversion: int to hex 
    145              Char_Array[POSIT_3] = diff + NUM_BASE;  
   \                     ??Passing_8:
   \   0001E2   5E42....     MOV.B   &diff, R14
   \   0001E6   7E503000     ADD.B   #0x30, R14
   \   0001EA   C24E....     MOV.B   R14, &Char_Array + 3
    146              
    147              // reconfigure array 
    148              Char_Array[POSIT_0]= NUM_BASE; 
   \   0001EE   F2403000.... MOV.B   #0x30, &Char_Array
    149              Char_Array[POSIT_1]= j;
   \   0001F4   D242........ MOV.B   &j, &Char_Array + 1
    150              Char_Array[POSIT_2]= i; 
   \   0001FA   D242........ MOV.B   &i, &Char_Array + 2
    151              
    152              // display process 
    153              display_1[POSIT_0] = NUM_BASE;
   \   000200   1F42....     MOV.W   &display_1, R15
   \   000204   FF4030000000 MOV.B   #0x30, 0(R15)
    154              display_1[POSIT_1] = NUM_BASE;
   \   00020A   1F42....     MOV.W   &display_1, R15
   \   00020E   FF4030000100 MOV.B   #0x30, 0x1(R15)
    155              display_1[POSIT_2] = NUM_BASE;
   \   000214   1F42....     MOV.W   &display_1, R15
   \   000218   FF4030000200 MOV.B   #0x30, 0x2(R15)
    156              display_1[POSIT_3] = NUM_BASE;
   \   00021E   1F42....     MOV.W   &display_1, R15
   \   000222   FF4030000300 MOV.B   #0x30, 0x3(R15)
    157              display_1[POSIT_4] = NUM_BASE;
   \   000228   1F42....     MOV.W   &display_1, R15
   \   00022C   FF4030000400 MOV.B   #0x30, 0x4(R15)
    158              display_1[POSIT_5] = NUM_BASE;
   \   000232   1F42....     MOV.W   &display_1, R15
   \   000236   FF4030000500 MOV.B   #0x30, 0x5(R15)
    159              display_1[POSIT_6] = Char_Array[POSIT_0];
   \   00023C   1F42....     MOV.W   &display_1, R15
   \   000240   DF42....0600 MOV.B   &Char_Array, 0x6(R15)
    160              display_1[POSIT_7] = Char_Array[POSIT_1];
   \   000246   1F42....     MOV.W   &display_1, R15
   \   00024A   DF42....0700 MOV.B   &Char_Array + 1, 0x7(R15)
    161              display_1[POSIT_8] = Char_Array[POSIT_2];
   \   000250   1F42....     MOV.W   &display_1, R15
   \   000254   DF42....0800 MOV.B   &Char_Array + 2, 0x8(R15)
    162              display_1[POSIT_9] = Char_Array[POSIT_3];
   \   00025A   1F42....     MOV.W   &display_1, R15
   \   00025E   DF42....0900 MOV.B   &Char_Array + 3, 0x9(R15)
    163              display_2 = "          ";
   \   000264   B240........ MOV.W   #`?<Constant "          ">`, &display_2
    164              display_3 = "          ";
   \   00026A   B240........ MOV.W   #`?<Constant "          ">`, &display_3
    165              display_4 = "          ";
   \   000270   B240........ MOV.W   #`?<Constant "          ">`, &display_4
    166              Display_Process(); 
   \   000276   ........     CALLA   #Display_Process
    167              
    168              // transmit/send the updated value 
    169              UCA1TXBUF = Char_Array[POSIT_0]; 
   \   00027A   5F42....     MOV.B   &Char_Array, R15
   \   00027E   4F4F         MOV.B   R15, R15
   \   000280   824FEE05     MOV.W   R15, &0x5ee
    170              Five_Msec_Delay(POSIT_2);
   \   000284   2C43         MOV.W   #0x2, R12
   \   000286   ........     CALLA   #Five_Msec_Delay
    171              UCA1TXBUF = Char_Array[POSIT_1];
   \   00028A   5F42....     MOV.B   &Char_Array + 1, R15
   \   00028E   4F4F         MOV.B   R15, R15
   \   000290   824FEE05     MOV.W   R15, &0x5ee
    172              Five_Msec_Delay(POSIT_2);
   \   000294   2C43         MOV.W   #0x2, R12
   \   000296   ........     CALLA   #Five_Msec_Delay
    173              UCA1TXBUF = Char_Array[POSIT_2];
   \   00029A   5F42....     MOV.B   &Char_Array + 2, R15
   \   00029E   4F4F         MOV.B   R15, R15
   \   0002A0   824FEE05     MOV.W   R15, &0x5ee
    174              Five_Msec_Delay(POSIT_2);
   \   0002A4   2C43         MOV.W   #0x2, R12
   \   0002A6   ........     CALLA   #Five_Msec_Delay
    175              UCA1TXBUF = Char_Array[POSIT_3];
   \   0002AA   5F42....     MOV.B   &Char_Array + 3, R15
   \   0002AE   4F4F         MOV.B   R15, R15
   \   0002B0   824FEE05     MOV.W   R15, &0x5ee
    176              Five_Msec_Delay(POSIT_2);
   \   0002B4   2C43         MOV.W   #0x2, R12
   \   0002B6   ........     CALLA   #Five_Msec_Delay
    177              
    178              // re-initialize to zero until next interrupt call 
    179              enabled_RX = POSIT_0; 
   \   0002BA   C243....     MOV.B   #0x0, &enabled_RX
    180              hundreds = POSIT_0; 
   \   0002BE   C243....     MOV.B   #0x0, &hundreds
    181              //Five_Msec_Delay(10);
    182            }
    183          }
   \                     ??Passing_4:
   \   0002C2   3A41         POP.W   R10
   \   0002C4   1001         RETA
   \   0002C6                REQUIRE _A_PBIN_L
   \   0002C6                REQUIRE _A_UCA1TXBUF_L
   \   0002C6                REQUIRE _A_UCA1RXBUF_L
    184          

   \                                 In  segment CODE, align 2
    185          void Counting(void){
   \                     Counting:
    186            // three counters: ones, tens, hundreds 
    187            diff = ORIGINAL; 
   \   000000   8243....     MOV.W   #0x0, &diff
    188            
    189            // checking for SW1 button press 
    190            if (!(P4IN & SW1)){
   \   000004   D2B32102     BIT.B   #0x1, &0x221
   \   000008   182C         JC      ??Counting_0
    191              UCA1TXBUF = TILDE;
   \   00000A   B2407E00EE05 MOV.W   #0x7e, &0x5ee
    192              Five_Msec_Delay(POSIT_5);
   \   000010   3C400500     MOV.W   #0x5, R12
   \   000014   ........     CALLA   #Five_Msec_Delay
    193              UCA1TXBUF = NUM_BASE;
   \   000018   B2403000EE05 MOV.W   #0x30, &0x5ee
    194              temp1 = UCA1RXBUF;
   \   00001E   1E42EC05     MOV.W   &0x5ec, R14
   \   000022   C24E....     MOV.B   R14, &temp1
    195              counter_ones = NUM_BASE; 
   \   000026   F2403000.... MOV.B   #0x30, &counter_ones
    196              counter_tens = NUM_BASE; 
   \   00002C   F2403000.... MOV.B   #0x30, &counter_tens
    197              counter_hunds = NUM_BASE;
   \   000032   F2403000.... MOV.B   #0x30, &counter_hunds
   \   000038   043C         JMP     ??Counting_1
    198            } else{
    199              //UCA1TXBUF = NUM_BASE;
    200              temp1 = UCA1RXBUF; 
   \                     ??Counting_0:
   \   00003A   1E42EC05     MOV.W   &0x5ec, R14
   \   00003E   C24E....     MOV.B   R14, &temp1
    201            }
    202            
    203            // calculating counter for ones place: int form  
    204            diff = temp1 - NUM_BASE; 
   \                     ??Counting_1:
   \   000042   5F42....     MOV.B   &temp1, R15
   \   000046   4F4F         MOV.B   R15, R15
   \   000048   3F50D0FF     ADD.W   #0xffd0, R15
   \   00004C   824F....     MOV.W   R15, &diff
    205            
    206            if(diff < POSIT_9){
   \   000050   B2900900.... CMP.W   #0x9, &diff
   \   000056   0234         JGE     ??Counting_2
    207              counter_ones++; 
   \   000058   D253....     ADD.B   #0x1, &counter_ones
    208            }
    209          // else if(counter_ones == NUM_BASE){
    210          //    diff = ORIGINAL; 
    211          //    counter_ones = NUM_BASE;
    212          //    counter_tens++; 
    213          //  }else if(counter_tens == NUM_9){
    214          //    counter_tens = NUM_BASE;
    215          //    counter_hunds++; 
    216          //  }
    217            
    218            // convert from int to hex value 
    219            temp1 = diff + NUM_BASE; 
   \                     ??Counting_2:
   \   00005C   5E42....     MOV.B   &diff, R14
   \   000060   7E503000     ADD.B   #0x30, R14
   \   000064   C24E....     MOV.B   R14, &temp1
    220            
    221            // display process 
    222            display_1[POSIT_0] = NUM_BASE;
   \   000068   1F42....     MOV.W   &display_1, R15
   \   00006C   FF4030000000 MOV.B   #0x30, 0(R15)
    223            display_1[POSIT_1] = NUM_BASE;
   \   000072   1F42....     MOV.W   &display_1, R15
   \   000076   FF4030000100 MOV.B   #0x30, 0x1(R15)
    224            display_1[POSIT_2] = NUM_BASE;
   \   00007C   1F42....     MOV.W   &display_1, R15
   \   000080   FF4030000200 MOV.B   #0x30, 0x2(R15)
    225            display_1[POSIT_3] = NUM_BASE;
   \   000086   1F42....     MOV.W   &display_1, R15
   \   00008A   FF4030000300 MOV.B   #0x30, 0x3(R15)
    226            display_1[POSIT_4] = NUM_BASE;
   \   000090   1F42....     MOV.W   &display_1, R15
   \   000094   FF4030000400 MOV.B   #0x30, 0x4(R15)
    227            display_1[POSIT_5] = NUM_BASE;
   \   00009A   1F42....     MOV.W   &display_1, R15
   \   00009E   FF4030000500 MOV.B   #0x30, 0x5(R15)
    228            display_1[POSIT_6] = NUM_BASE;
   \   0000A4   1F42....     MOV.W   &display_1, R15
   \   0000A8   FF4030000600 MOV.B   #0x30, 0x6(R15)
    229            display_1[POSIT_7] = counter_hunds;
   \   0000AE   1F42....     MOV.W   &display_1, R15
   \   0000B2   DF42....0700 MOV.B   &counter_hunds, 0x7(R15)
    230            display_1[POSIT_8] = counter_tens;
   \   0000B8   1F42....     MOV.W   &display_1, R15
   \   0000BC   DF42....0800 MOV.B   &counter_tens, 0x8(R15)
    231            display_1[POSIT_9] = counter_ones;
   \   0000C2   1F42....     MOV.W   &display_1, R15
   \   0000C6   DF42....0900 MOV.B   &counter_ones, 0x9(R15)
    232            display_2 = "          ";
   \   0000CC   B240........ MOV.W   #`?<Constant "          ">`, &display_2
    233            display_3 = "          ";
   \   0000D2   B240........ MOV.W   #`?<Constant "          ">`, &display_3
    234            display_4 = "          ";
   \   0000D8   B240........ MOV.W   #`?<Constant "          ">`, &display_4
    235            Display_Process();
   \   0000DE   ........     CALLA   #Display_Process
    236            
    237            // transmit 
    238            UCA1TXBUF = temp1; 
   \   0000E2   5F42....     MOV.B   &temp1, R15
   \   0000E6   4F4F         MOV.B   R15, R15
   \   0000E8   824FEE05     MOV.W   R15, &0x5ee
    239            Five_Msec_Delay(POSIT_5); 
   \   0000EC   3C400500     MOV.W   #0x5, R12
   \   0000F0   ........     BRA     #Five_Msec_Delay
   \   0000F4                REQUIRE _A_PBIN_L
   \   0000F4                REQUIRE _A_UCA1TXBUF_L
   \   0000F4                REQUIRE _A_UCA1RXBUF_L
    240          }

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "          ">`:
   \   000000   202020202020 DC8 "          "
   \            2020202000  

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      4   Counting
        4   -> Display_Process
        0   -> Five_Msec_Delay
        4   -> Five_Msec_Delay
      4   P6Demo
        4   -> Passing
      6   Passing
        6   -> Display_Process
        6   -> Five_Msec_Delay


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      11  ?<Constant "          ">
     244  Counting
       8  P6Demo
     710  Passing
       2  _A_PBIN_L
       2  _A_UCA1RXBUF_L
       2  _A_UCA1TXBUF_L

 
 962 bytes in segment CODE
   6 bytes in segment DATA16_AN
  11 bytes in segment DATA16_C
 
 962 bytes of CODE  memory
  11 bytes of CONST memory
   0 bytes of DATA  memory (+ 6 bytes shared)

Errors: none
Warnings: none
