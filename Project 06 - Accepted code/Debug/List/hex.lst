###############################################################################
#
# IAR C/C++ Compiler V6.30.2.940/W32 for MSP430           02/Nov/2015  18:15:37
# Copyright 1996-2015 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for Texas Instruments MSP430, 8K KickStart Edition 6.30
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  C:\Users\Christopher\Documents\ECE 306\Project_06\hex.c
#    Command line  =  
#        "C:\Users\Christopher\Documents\ECE 306\Project_06\hex.c" -lC
#        "C:\Users\Christopher\Documents\ECE 306\Project_06\Debug\List\" -o
#        "C:\Users\Christopher\Documents\ECE 306\Project_06\Debug\Obj\"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa --debug
#        -D__MSP430FR5739__ -e --double=32 --dlib_config "D:\IAR Embedded
#        Workbench\430\lib\dlib\dl430xlsfn.h" --core=430X --data_model=small
#        -On --multiplier=32 --hw_workaround=CPU40 --code_model=large
#    List file     =  
#        C:\Users\Christopher\Documents\ECE 306\Project_06\Debug\List\hex.lst
#    Object file   =  
#        C:\Users\Christopher\Documents\ECE 306\Project_06\Debug\Obj\hex.r43
#
###############################################################################

C:\Users\Christopher\Documents\ECE 306\Project_06\hex.c
      1          //******************************************************************************
      2          //
      3          //  Description: This file contains the hex conversion and display routine
      4          //
      5          //
      6          //  Christopher Woedy
      7          //  Sept 2015
      8          //  Built with IAR Embedded Workbench Version: V4.10A/W32 (6.30.3)
      9          //******************************************************************************
     10          
     11          //Points to Header files for Preprocessing
     12          #include  "msp430.h"
     13          #include  "functions.h"
     14          #include  "macros.h"
     15          

   \                                 In  segment CODE, align 2
     16          void Display_ADC (void){
   \                     Display_ADC:
   \   000000   1B15         PUSHM.W #0x2, R11
     17          //******************************************************************************
     18          //
     19          //  Description: This file contains the hex conversion and display routine with
     20          //  relation to the ADC
     21          //
     22          //  Christopher Woedy
     23          //  Sept 2015
     24          //  Built with IAR Embedded Workbench Version: V4.10A/W32 (6.30.3)
     25          //
     26          // Globals: ADC_Thumb, ADC_Right_Detector, ADC_Left_Detector
     27          // adc_RD_Enable, adc_LD_Enable
     28          //
     29          // Passed:
     30          //
     31          // Local: tmpWork, ADCtemp
     32          //
     33          // Return: VOID
     34          //
     35          //****************************************************************************** 
     36            
     37            // Initialize
     38            unsigned int ADCtemp = INITIAL;
   \   000002   0B43         MOV.W   #0x0, R11
     39            unsigned int tmpWork = INITIAL;
   \   000004   0A43         MOV.W   #0x0, R10
     40              
     41            if(adc_RD_Enable)ADCtemp = ADC_Right_Detector;        // HEX value to read
   \   000006   C293....     CMP.B   #0x0, &adc_RD_Enable
   \   00000A   0224         JEQ     ??Display_ADC_0
   \   00000C   1B42....     MOV.W   &ADC_Right_Detector, R11
     42            if(adc_LD_Enable)ADCtemp = ADC_Left_Detector;         // HEX value to read 
   \                     ??Display_ADC_0:
   \   000010   C293....     CMP.B   #0x0, &adc_LD_Enable
   \   000014   0224         JEQ     ??Display_ADC_1
   \   000016   1B42....     MOV.W   &ADC_Left_Detector, R11
     43            
     44            tmpWork = ADCtemp;                                    // Temporary Operator
   \                     ??Display_ADC_1:
   \   00001A   0A4B         MOV.W   R11, R10
     45            
     46            // First Nibble
     47            tmpWork = tmpWork & FIRST_NIBBLE;                     // Work with least significant nibble
   \   00001C   3AF00F00     AND.W   #0xf, R10
     48            if (tmpWork >= LETTER_START) {
   \   000020   3A900A00     CMP.W   #0xa, R10
   \   000024   0328         JNC     ??Display_ADC_2
     49              tmpWork += LETTER_OP;                               // Code for 0xA - 0xF
   \   000026   3A503700     ADD.W   #0x37, R10
   \   00002A   023C         JMP     ??Display_ADC_3
     50            }
     51            else {
     52              tmpWork |= NUMBER_OP;                               // Code for 0x0 - 0x9
   \                     ??Display_ADC_2:
   \   00002C   3AD03000     BIS.W   #0x30, R10
     53            }
     54            
     55            if(adc_RD_Enable)display_3[LINE_POS_L8] = tmpWork;    // Display character
   \                     ??Display_ADC_3:
   \   000030   C293....     CMP.B   #0x0, &adc_RD_Enable
   \   000034   0424         JEQ     ??Display_ADC_4
   \   000036   1F42....     MOV.W   &display_3, R15
   \   00003A   CF4A0800     MOV.B   R10, 0x8(R15)
     56            if(adc_LD_Enable)display_2[LINE_POS_L8] = tmpWork;    // Display character
   \                     ??Display_ADC_4:
   \   00003E   C293....     CMP.B   #0x0, &adc_LD_Enable
   \   000042   0424         JEQ     ??Display_ADC_5
   \   000044   1F42....     MOV.W   &display_2, R15
   \   000048   CF4A0800     MOV.B   R10, 0x8(R15)
     57            
     58            // Second Nibble
     59            tmpWork = ADCtemp;                                    // Use original value
   \                     ??Display_ADC_5:
   \   00004C   0A4B         MOV.W   R11, R10
     60            tmpWork &= SECOND_NIBBLE;                             // Second nibble
   \   00004E   3AF0F000     AND.W   #0xf0, R10
     61            tmpWork >>= SHIFT_4;                                  // Shift to lowest order bits
   \   000052   5A0F         RRUM.W  #0x4, R10
     62            if (tmpWork >= LETTER_START) {
   \   000054   3A900A00     CMP.W   #0xa, R10
   \   000058   0328         JNC     ??Display_ADC_6
     63              tmpWork += LETTER_OP;                               // Code for 0xA - 0xF
   \   00005A   3A503700     ADD.W   #0x37, R10
   \   00005E   023C         JMP     ??Display_ADC_7
     64            }
     65            else {
     66              tmpWork |= NUMBER_OP;                               // Code for 0x0 - 0x9
   \                     ??Display_ADC_6:
   \   000060   3AD03000     BIS.W   #0x30, R10
     67            }
     68            if(adc_RD_Enable)display_3[LINE_POS_L7] = tmpWork;    // Display character
   \                     ??Display_ADC_7:
   \   000064   C293....     CMP.B   #0x0, &adc_RD_Enable
   \   000068   0424         JEQ     ??Display_ADC_8
   \   00006A   1F42....     MOV.W   &display_3, R15
   \   00006E   CF4A0700     MOV.B   R10, 0x7(R15)
     69            if(adc_LD_Enable)display_2[LINE_POS_L7] = tmpWork;    // Display character
   \                     ??Display_ADC_8:
   \   000072   C293....     CMP.B   #0x0, &adc_LD_Enable
   \   000076   0424         JEQ     ??Display_ADC_9
   \   000078   1F42....     MOV.W   &display_2, R15
   \   00007C   CF4A0700     MOV.B   R10, 0x7(R15)
     70            
     71            // Third Nibble
     72            tmpWork = ADCtemp;                                    // Use original value
   \                     ??Display_ADC_9:
   \   000080   0A4B         MOV.W   R11, R10
     73            tmpWork &= THIRD_NIBBLE;                              // Third nibble
   \   000082   3AF0000F     AND.W   #0xf00, R10
     74            tmpWork >>= SHIFT_8;                                  // Shift to lowest order bits
   \   000086   8A10         SWPB    R10
   \   000088   3AF0FF00     AND.W   #0xff, R10
     75            if (tmpWork >= LETTER_START) {
   \   00008C   3A900A00     CMP.W   #0xa, R10
   \   000090   0328         JNC     ??Display_ADC_10
     76              tmpWork += LETTER_OP;                               // Code for 0xA - 0xF
   \   000092   3A503700     ADD.W   #0x37, R10
   \   000096   023C         JMP     ??Display_ADC_11
     77            }
     78            else {
     79              tmpWork |= NUMBER_OP;                               // Code for 0x0 - 0x9
   \                     ??Display_ADC_10:
   \   000098   3AD03000     BIS.W   #0x30, R10
     80            }
     81            if(adc_RD_Enable)display_3[LINE_POS_L6] = tmpWork;    // Display character
   \                     ??Display_ADC_11:
   \   00009C   C293....     CMP.B   #0x0, &adc_RD_Enable
   \   0000A0   0424         JEQ     ??Display_ADC_12
   \   0000A2   1F42....     MOV.W   &display_3, R15
   \   0000A6   CF4A0600     MOV.B   R10, 0x6(R15)
     82            if(adc_LD_Enable)display_2[LINE_POS_L6] = tmpWork;    // Display character
   \                     ??Display_ADC_12:
   \   0000AA   C293....     CMP.B   #0x0, &adc_LD_Enable
   \   0000AE   0424         JEQ     ??Display_ADC_13
   \   0000B0   1F42....     MOV.W   &display_2, R15
   \   0000B4   CF4A0600     MOV.B   R10, 0x6(R15)
     83          
     84            
     85            // Push changes to display
     86            Display_Process();
   \                     ??Display_ADC_13:
   \   0000B8   ........     CALLA   #Display_Process
     87          }
   \   0000BC   1A17         POPM.W  #0x2, R11
   \   0000BE   1001         RETA
     88          

   \                                 In  segment CODE, align 2
     89          unsigned int intToHex (unsigned int intTemp){
   \                     intToHex:
   \   000000   0F4C         MOV.W   R12, R15
     90          //******************************************************************************
     91          //
     92          //  Description: This functions implements the integer to ASCII conversion
     93          //
     94          //  Christopher Woedy
     95          //  Sept 2015
     96          //  Built with IAR Embedded Workbench Version: V4.10A/W32 (6.30.3)
     97          //
     98          // Globals: 
     99          //
    100          // Passed: conver
    101          //
    102          // Local: tmpHEX, intTemp
    103          //
    104          // Return: VOID
    105          //
    106          //****************************************************************************** 
    107            
    108            // Initialize
    109            unsigned int tmpHEX = INITIAL;
   \   000002   0E43         MOV.W   #0x0, R14
    110            unsigned int tmpReturn = INITIAL;
   \   000004   0C43         MOV.W   #0x0, R12
    111            
    112            tmpHEX = intTemp;                                    // Temporary Operator
   \   000006   0E4F         MOV.W   R15, R14
    113            
    114            // First Nibble
    115            tmpHEX &= FIRST_NYBL;                     // Work with least significant nibble
   \   000008   3EF00F00     AND.W   #0xf, R14
    116            if (tmpHEX >= LETTER_START) {
   \   00000C   3E900A00     CMP.W   #0xa, R14
   \   000010   0328         JNC     ??intToHex_0
    117              tmpHEX += LETTER_OP;                               // Code for 0xA - 0xF
   \   000012   3E503700     ADD.W   #0x37, R14
   \   000016   023C         JMP     ??intToHex_1
    118            }
    119            else {
    120              tmpHEX |= NUMBER_OP;                               // Code for 0x0 - 0x9
   \                     ??intToHex_0:
   \   000018   3ED03000     BIS.W   #0x30, R14
    121            }
    122            
    123            tmpReturn |= tmpHEX;    // Display character
   \                     ??intToHex_1:
   \   00001C   0CDE         BIS.W   R14, R12
    124            
    125            // Second Nibble
    126            tmpHEX = intTemp;                                    // Use original value
   \   00001E   0E4F         MOV.W   R15, R14
    127            tmpHEX &= SECOND_NYBL;                             // Second nibble
   \   000020   3EF0F000     AND.W   #0xf0, R14
    128            tmpHEX >>= SHIFT_4;                                  // Shift to lowest order bits
   \   000024   5E0F         RRUM.W  #0x4, R14
    129            if (tmpHEX >= LETTER_START) {
   \   000026   3E900A00     CMP.W   #0xa, R14
   \   00002A   0328         JNC     ??intToHex_2
    130              tmpHEX += LETTER_OP;                               // Code for 0xA - 0xF
   \   00002C   3E503700     ADD.W   #0x37, R14
   \   000030   023C         JMP     ??intToHex_3
    131            }
    132            else {
    133              tmpHEX |= NUMBER_OP;                               // Code for 0x0 - 0x9
   \                     ??intToHex_2:
   \   000032   3ED03000     BIS.W   #0x30, R14
    134            }
    135            tmpHEX <<= SHIFT_4;
   \                     ??intToHex_3:
   \   000036   5E0E         RLAM.W  #0x4, R14
    136            tmpReturn |= tmpHEX;    // Display character
   \   000038   0CDE         BIS.W   R14, R12
    137           
    138            tmpReturn &= FIRST_BYTE;
   \   00003A   3CF0FF00     AND.W   #0xff, R12
    139            
    140            return tmpReturn;
   \   00003E   1001         RETA
    141           
    142          }
    143          

   \                                 In  segment CODE, align 2
    144          void hexToInt (unsigned int hexTemp){
   \                     hexToInt:
    145          //******************************************************************************
    146          //
    147          //  Description: This functions implements the ASCII to Integer conversion
    148          //
    149          //  Christopher Woedy
    150          //  Sept 2015
    151          //  Built with IAR Embedded Workbench Version: V4.10A/W32 (6.30.3)
    152          //
    153          // Globals: 
    154          //
    155          // Passed: conver
    156          //
    157          // Local: tmpHEX, intTemp
    158          //
    159          // Return: VOID
    160          //
    161          //****************************************************************************** 
    162            
    163            tempCount = hexTemp;
   \   000000   824C....     MOV.W   R12, &tempCount
    164            
    165            tempDisplay[SW_SEL_0] = NUMBER_OP;
   \   000004   B2403000.... MOV.W   #0x30, &tempDisplay
    166            tempDisplay[SW_SEL_1] = NUMBER_OP;
   \   00000A   B2403000.... MOV.W   #0x30, &tempDisplay + 2
    167            tempDisplay[SW_SEL_2] = NUMBER_OP;
   \   000010   B2403000.... MOV.W   #0x30, &tempDisplay + 4
    168            tempDisplay[SW_SEL_3] = NUMBER_OP;
   \   000016   B2403000.... MOV.W   #0x30, &tempDisplay + 6
    169            tempDisplay[SW_SEL_4] = NUMBER_OP;
   \   00001C   B2403000.... MOV.W   #0x30, &tempDisplay + 8
    170            tempDisplay[SW_SEL_5] = NUMBER_OP;
   \   000022   B2403000.... MOV.W   #0x30, &tempDisplay + 10
    171            tempDisplay[SW_SEL_6] = NUMBER_OP;
   \   000028   B2403000.... MOV.W   #0x30, &tempDisplay + 12
    172            tempDisplay[SW_SEL_7] = NUMBER_OP;
   \   00002E   B2403000.... MOV.W   #0x30, &tempDisplay + 14
    173            tempDisplay[SW_SEL_8] = NUMBER_OP;
   \   000034   B2403000.... MOV.W   #0x30, &tempDisplay + 16
    174            tempDisplay[SW_SEL_9] = NUMBER_OP;
   \   00003A   B2403000.... MOV.W   #0x30, &tempDisplay + 18
    175            
    176            
    177            while (tempCount > INITIAL) {
   \                     ??hexToInt_0:
   \   000040   8293....     CMP.W   #0x0, &tempCount
   \   000044   B524         JEQ     ??hexToInt_1
    178              
    179              if (tempDisplay[SW_SEL_0] > NUMBER_MAX) {
   \   000046   B2903A00.... CMP.W   #0x3a, &tempDisplay
   \   00004C   0528         JNC     ??hexToInt_2
    180                   tempDisplay[SW_SEL_1]++;
   \   00004E   9253....     ADD.W   #0x1, &tempDisplay + 2
    181                   tempDisplay[SW_SEL_0] = NUMBER_OP;
   \   000052   B2403000.... MOV.W   #0x30, &tempDisplay
    182                 }    
    183                if (tempDisplay[SW_SEL_1] == NUMBER_MAX) {
   \                     ??hexToInt_2:
   \   000058   B2903900.... CMP.W   #0x39, &tempDisplay + 2
   \   00005E   0520         JNE     ??hexToInt_3
    184                   tempDisplay[SW_SEL_2]++;
   \   000060   9253....     ADD.W   #0x1, &tempDisplay + 4
    185                   tempDisplay[SW_SEL_1] = NUMBER_OP;
   \   000064   B2403000.... MOV.W   #0x30, &tempDisplay + 2
    186                 }
    187                 if (tempDisplay[SW_SEL_2] == NUMBER_MAX) {
   \                     ??hexToInt_3:
   \   00006A   B2903900.... CMP.W   #0x39, &tempDisplay + 4
   \   000070   0520         JNE     ??hexToInt_4
    188                   tempDisplay[SW_SEL_3]++;
   \   000072   9253....     ADD.W   #0x1, &tempDisplay + 6
    189                   tempDisplay[SW_SEL_2] = NUMBER_OP;
   \   000076   B2403000.... MOV.W   #0x30, &tempDisplay + 4
    190                 }
    191                 if (tempDisplay[SW_SEL_3] == NUMBER_MAX) {
   \                     ??hexToInt_4:
   \   00007C   B2903900.... CMP.W   #0x39, &tempDisplay + 6
   \   000082   0520         JNE     ??hexToInt_5
    192                   tempDisplay[SW_SEL_4]++;
   \   000084   9253....     ADD.W   #0x1, &tempDisplay + 8
    193                   tempDisplay[SW_SEL_3] = NUMBER_OP;
   \   000088   B2403000.... MOV.W   #0x30, &tempDisplay + 6
    194                 }
    195                 if (tempDisplay[SW_SEL_5] == NUMBER_MAX) {
   \                     ??hexToInt_5:
   \   00008E   B2903900.... CMP.W   #0x39, &tempDisplay + 10
   \   000094   0520         JNE     ??hexToInt_6
    196                   tempDisplay[SW_SEL_6]++;
   \   000096   9253....     ADD.W   #0x1, &tempDisplay + 12
    197                   tempDisplay[SW_SEL_5] = NUMBER_OP;
   \   00009A   B2403000.... MOV.W   #0x30, &tempDisplay + 10
    198                 }
    199                 if (tempDisplay[SW_SEL_6] == NUMBER_MAX) {
   \                     ??hexToInt_6:
   \   0000A0   B2903900.... CMP.W   #0x39, &tempDisplay + 12
   \   0000A6   0520         JNE     ??hexToInt_7
    200                   tempDisplay[SW_SEL_7]++;
   \   0000A8   9253....     ADD.W   #0x1, &tempDisplay + 14
    201                   tempDisplay[SW_SEL_6] = NUMBER_OP;
   \   0000AC   B2403000.... MOV.W   #0x30, &tempDisplay + 12
    202                 }
    203                 if (tempDisplay[SW_SEL_7] == NUMBER_MAX) {
   \                     ??hexToInt_7:
   \   0000B2   B2903900.... CMP.W   #0x39, &tempDisplay + 14
   \   0000B8   0520         JNE     ??hexToInt_8
    204                   tempDisplay[SW_SEL_8]++;
   \   0000BA   9253....     ADD.W   #0x1, &tempDisplay + 16
    205                   tempDisplay[SW_SEL_7] = NUMBER_OP;
   \   0000BE   B2403000.... MOV.W   #0x30, &tempDisplay + 14
    206                 }
    207                 if (tempDisplay[SW_SEL_8] == NUMBER_MAX) {
   \                     ??hexToInt_8:
   \   0000C4   B2903900.... CMP.W   #0x39, &tempDisplay + 16
   \   0000CA   0520         JNE     ??hexToInt_9
    208                   tempDisplay[SW_SEL_9]++;
   \   0000CC   9253....     ADD.W   #0x1, &tempDisplay + 18
    209                   tempDisplay[SW_SEL_8] = NUMBER_OP;
   \   0000D0   B2403000.... MOV.W   #0x30, &tempDisplay + 16
    210                 }
    211                 if (tempDisplay[SW_SEL_9] == NUMBER_MAX) {
   \                     ??hexToInt_9:
   \   0000D6   B2903900.... CMP.W   #0x39, &tempDisplay + 18
   \   0000DC   3220         JNE     ??hexToInt_10
    212                   display_3[SW_SEL_0] = NUMBER_OP;
   \   0000DE   1F42....     MOV.W   &display_3, R15
   \   0000E2   FF4030000000 MOV.B   #0x30, 0(R15)
    213                   display_3[SW_SEL_1] = NUMBER_OP;
   \   0000E8   1F42....     MOV.W   &display_3, R15
   \   0000EC   FF4030000100 MOV.B   #0x30, 0x1(R15)
    214                   display_3[SW_SEL_2] = NUMBER_OP;
   \   0000F2   1F42....     MOV.W   &display_3, R15
   \   0000F6   FF4030000200 MOV.B   #0x30, 0x2(R15)
    215                   display_3[SW_SEL_3] = NUMBER_OP;
   \   0000FC   1F42....     MOV.W   &display_3, R15
   \   000100   FF4030000300 MOV.B   #0x30, 0x3(R15)
    216                   display_3[SW_SEL_4] = NUMBER_OP;
   \   000106   1F42....     MOV.W   &display_3, R15
   \   00010A   FF4030000400 MOV.B   #0x30, 0x4(R15)
    217                   display_3[SW_SEL_5] = NUMBER_OP;
   \   000110   1F42....     MOV.W   &display_3, R15
   \   000114   FF4030000500 MOV.B   #0x30, 0x5(R15)
    218                   display_3[SW_SEL_6] = NUMBER_OP;
   \   00011A   1F42....     MOV.W   &display_3, R15
   \   00011E   FF4030000600 MOV.B   #0x30, 0x6(R15)
    219                   display_3[SW_SEL_7] = NUMBER_OP;
   \   000124   1F42....     MOV.W   &display_3, R15
   \   000128   FF4030000700 MOV.B   #0x30, 0x7(R15)
    220                   display_3[SW_SEL_8] = NUMBER_OP;
   \   00012E   1F42....     MOV.W   &display_3, R15
   \   000132   FF4030000800 MOV.B   #0x30, 0x8(R15)
    221                   display_3[SW_SEL_9] = NUMBER_OP;
   \   000138   1F42....     MOV.W   &display_3, R15
   \   00013C   FF4030000900 MOV.B   #0x30, 0x9(R15)
    222                 }
    223              
    224                  display_3[SW_SEL_0] = tempDisplay[SW_SEL_9];
   \                     ??hexToInt_10:
   \   000142   1F42....     MOV.W   &display_3, R15
   \   000146   DF42....0000 MOV.B   &tempDisplay + 18, 0(R15)
    225                  display_3[SW_SEL_1] = tempDisplay[SW_SEL_8];
   \   00014C   1F42....     MOV.W   &display_3, R15
   \   000150   DF42....0100 MOV.B   &tempDisplay + 16, 0x1(R15)
    226                  display_3[SW_SEL_2] = tempDisplay[SW_SEL_7];
   \   000156   1F42....     MOV.W   &display_3, R15
   \   00015A   DF42....0200 MOV.B   &tempDisplay + 14, 0x2(R15)
    227                  display_3[SW_SEL_3] = tempDisplay[SW_SEL_6];
   \   000160   1F42....     MOV.W   &display_3, R15
   \   000164   DF42....0300 MOV.B   &tempDisplay + 12, 0x3(R15)
    228                  display_3[SW_SEL_4] = tempDisplay[SW_SEL_5];
   \   00016A   1F42....     MOV.W   &display_3, R15
   \   00016E   DF42....0400 MOV.B   &tempDisplay + 10, 0x4(R15)
    229                  display_3[SW_SEL_5] = tempDisplay[SW_SEL_4];
   \   000174   1F42....     MOV.W   &display_3, R15
   \   000178   DF42....0500 MOV.B   &tempDisplay + 8, 0x5(R15)
    230                  display_3[SW_SEL_6] = tempDisplay[SW_SEL_3];
   \   00017E   1F42....     MOV.W   &display_3, R15
   \   000182   DF42....0600 MOV.B   &tempDisplay + 6, 0x6(R15)
    231                  display_3[SW_SEL_7] = tempDisplay[SW_SEL_2];
   \   000188   1F42....     MOV.W   &display_3, R15
   \   00018C   DF42....0700 MOV.B   &tempDisplay + 4, 0x7(R15)
    232                  display_3[SW_SEL_8] = tempDisplay[SW_SEL_1];
   \   000192   1F42....     MOV.W   &display_3, R15
   \   000196   DF42....0800 MOV.B   &tempDisplay + 2, 0x8(R15)
    233                  display_3[SW_SEL_9] = tempDisplay[SW_SEL_0];
   \   00019C   1F42....     MOV.W   &display_3, R15
   \   0001A0   DF42....0900 MOV.B   &tempDisplay, 0x9(R15)
    234                  
    235              tempDisplay[SW_SEL_0]++;
   \   0001A6   9253....     ADD.W   #0x1, &tempDisplay
    236              tempCount--;
   \   0001AA   B253....     ADD.W   #0xffff, &tempCount
   \   0001AE   483F         JMP     ??hexToInt_0
    237              
    238            }
    239           
    240          }
   \                     ??hexToInt_1:
   \   0001B0   1001         RETA

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      8   Display_ADC
        8   -> Display_Process
      4   hexToInt
      4   intToHex


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
     192  Display_ADC
     434  hexToInt
      64  intToHex

 
 690 bytes in segment CODE
 
 690 bytes of CODE memory

Errors: none
Warnings: none
