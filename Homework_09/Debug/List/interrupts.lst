###############################################################################
#
# IAR C/C++ Compiler V6.30.2.940/W32 for MSP430           13/Nov/2015  17:31:00
# Copyright 1996-2015 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for Texas Instruments MSP430, 8K KickStart Edition 6.30
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  
#        \\vmware-host\Shared
#        Folders\Desktop\ECE306Code\Homework_09\interrupts.c
#    Command line  =  
#        "\\vmware-host\Shared
#        Folders\Desktop\ECE306Code\Homework_09\interrupts.c" -lC
#        "\\vmware-host\Shared
#        Folders\Desktop\ECE306Code\Homework_09\Debug\List\" -o
#        "\\vmware-host\Shared
#        Folders\Desktop\ECE306Code\Homework_09\Debug\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --debug
#        -D__MSP430FR5739__ -e --double=32 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.2\430\lib\dlib\dl430xlsfn.h"
#        --core=430X --data_model=small -On --multiplier=32
#        --hw_workaround=CPU40 --code_model=large
#    List file     =  
#        \\vmware-host\Shared
#        Folders\Desktop\ECE306Code\Homework_09\Debug\List\interrupts.lst
#    Object file   =  
#        \\vmware-host\Shared
#        Folders\Desktop\ECE306Code\Homework_09\Debug\Obj\interrupts.r43
#
###############################################################################

\\vmware-host\Shared Folders\Desktop\ECE306Code\Homework_09\interrupts.c
      1          #include  "macros.h"
      2          #include  "msp430.h"

   \                                 In  segment DATA16_AN, at 0x700
   \   union <unnamed> _A_ADC10CTL0_L
   \                     _A_ADC10CTL0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x70a
   \   union <unnamed> _A_ADC10MCTL0_L
   \                     _A_ADC10MCTL0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x712
   \   union <unnamed> _A_ADC10MEM0_L
   \                     _A_ADC10MEM0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x71e
   \   union <unnamed> _A_ADC10IV_L
   \                     _A_ADC10IV_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x322
   \   union <unnamed> _A_PJOUT_L
   \                     _A_PJOUT_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x352
   \   unsigned short volatile TA0CCR0
   \                     TA0CCR0:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x5ec
   \   union <unnamed> _A_UCA1RXBUF_L
   \                     _A_UCA1RXBUF_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x5fe
   \   unsigned short volatile UCA1IV
   \                     UCA1IV:
   \   000000                DS8 2
      3          #include  "functions.h"
      4          /*******************************************************************************
      5          *        Author: Steffon Brigman
      6          *        Date:   October 2015
      7          *        Description: This file contains all interrupts used within this project.
      8          *        Built with IAR Embedded Workbench Version: V7.0.5/W32 (6.10.5)
      9          *
     10          *        File name: interrupts.c
     11          *        Passed : No variables passed 
     12          *        Locals: No variables defined
     13          *        Returned: no values returned 
     14          *        Globlas: ADC_Thumb
     15          *******************************************************************************/
     16          // TimerA0 0 Interrupt handler
     17          #pragma vector = TIMER0_A0_VECTOR
     18          

   \                                 In  segment ISR_CODE, align 2
     19          __interrupt void Timer0_A0_ISR(void){
   \                     Timer0_A0_ISR:
   \   000000   3F15         PUSHM.W #0x4, R15
     20            /*******************************************************************************
     21          *        Author: Steffon Brigman
     22          *        Date:   October 2015
     23          *        Description: This functions is an interrupt used to control the motors.
     24          *        Built with IAR Embedded Workbench Version: V7.0.5/W32 (6.10.5)
     25          *
     26          *        Function name: Timer0_A0_ISR
     27          *        Passed : No variables passed 
     28          *        Locals: TA0CCR0, ISR_COUNT
     29          *        Returned: no values returned 
     30          *        Globlas: no variables defined
     31          *******************************************************************************/
     32          
     33           PJOUT ^= LED3; // Test signal
   \   000002   A2E22203     XOR.W   #0x4, &0x322
     34           ISR_COUNT++;
   \   000006   9253....     ADD.W   #0x1, &ISR_COUNT
     35           UPDATE_LCD++;
   \   00000A   9253....     ADD.W   #0x1, &UPDATE_LCD
     36           if(UPDATE_LCD == LCD) {Display_Process(); UPDATE_LCD = ZERO;} // reset UPDATE_LCD every 200ms
   \   00000E   B2906400.... CMP.W   #0x64, &UPDATE_LCD
   \   000014   0420         JNE     ??Timer0_A0_ISR_0
   \   000016   ........     CALLA   #Display_Process
   \   00001A   8243....     MOV.W   #0x0, &UPDATE_LCD
     37           TA0CCR0 += TA0CCR0_INTERVAL; // Add Offset to TACCR0
   \                     ??Timer0_A0_ISR_0:
   \   00001E   B25010275203 ADD.W   #0x2710, &0x352
     38           if(ISR_COUNT>FIVE_SECONDS){
   \   000024   B290FC00.... CMP.W   #0xfc, &ISR_COUNT
   \   00002A   0238         JL      ??Timer0_A0_ISR_1
     39             ISR_COUNT = ZERO;
   \   00002C   8243....     MOV.W   #0x0, &ISR_COUNT
     40           }
     41          }
   \                     ??Timer0_A0_ISR_1:
   \   000030   3C17         POPM.W  #0x4, R15
   \   000032   0013         RETI
   \   000034                REQUIRE _A_PJOUT_L
   \   000034                REQUIRE TA0CCR0
     42          
     43          //------------------------------------------------------------------------------
     44          // ADC10 interrupt service routine
     45          // ADC_Right_Detector; // A00 ADC10INCH_0 - P1.0
     46          // ADC_Left_Detector; // A01 ADC10INCH_1 - P1.1
     47          // ADC_Thumb; // A03 ADC10INCH_3 - P1.3
     48          // ADC_Temp; // A10 ADC10INCH_10 – Temperature REF module
     49          // ADC_Bat; // A11 ADC10INCH_11 - Internal
     50          #pragma vector=ADC10_VECTOR

   \                                 In  segment ISR_CODE, align 2
     51          __interrupt void ADC10_ISR(void){
   \                     ADC10_ISR:
   \   000000   0F12         PUSH.W  R15
     52            /*******************************************************************************
     53          *        Author: Steffon Brigman
     54          *        Date:   October 2015
     55          *        Description: This functions is an interrupt used to control the motors.
     56          *        Built with IAR Embedded Workbench Version: V7.0.5/W32 (6.10.5)
     57          *
     58          *        Function name: ADC10_ISR
     59          *        Passed : No variables passed 
     60          *        Locals: none declared
     61          *        Returned: no values returned 
     62          *        Globlas: ADC_Right_Detector, ADC_Left_Detector, ADC_Thumb
     63          *******************************************************************************/
     64           switch(__even_in_range(ADC10IV,12)) {
   \   000002   1F421E07     MOV.W   &0x71e, R15
   \   000006   E00F         ADDA    R15, PC
   \                     `?<Jumptable for ADC10_ISR>_0`:
   \   000008   2A3C         JMP     ??ADC10_ISR_1
   \   00000A   293C         JMP     ??ADC10_ISR_1
   \   00000C   283C         JMP     ??ADC10_ISR_1
   \   00000E   273C         JMP     ??ADC10_ISR_1
   \   000010   263C         JMP     ??ADC10_ISR_1
   \   000012   253C         JMP     ??ADC10_ISR_1
   \   000014   003C         JMP     ??ADC10_ISR_5
     65           case 0: break; // No interrupt
     66           case 2: break; // conversion result overflow
     67           case 4: break; // conversion time overflow
     68           case 6: break; // ADC10HI
     69           case 8: break; // ADC10LO
     70           case 10: break; // ADC10IN
     71           case 12:
     72                 // Need this to change the ADC10INCH_x value.
     73               ADC10CTL0 &= ~ADC10ENC; // Toggle ENC bit.
   \                     ??ADC10_ISR_5:
   \   000016   A2C30007     BIC.W   #0x2, &0x700
     74               
     75               switch (ADC_Channel){
   \   00001A   1F42....     MOV.W   &ADC_Channel, R15
   \   00001E   0F83         SUB.W   #0x0, R15
   \   000020   0524         JEQ     ??ADC10_ISR_2
   \   000022   1F83         SUB.W   #0x1, R15
   \   000024   0B24         JEQ     ??ADC10_ISR_3
   \   000026   1F83         SUB.W   #0x1, R15
   \   000028   1124         JEQ     ??ADC10_ISR_4
   \   00002A   163C         JMP     ??ADC10_ISR_0
     76               case Right_Detector:
     77               ADC10MCTL0 = ADC10INCH_0; //  channel A0
   \                     ??ADC10_ISR_2:
   \   00002C   82430A07     MOV.W   #0x0, &0x70a
     78               ADC_Right_Detector = ADC10MEM0; // Read Channel A0
   \   000030   92421207.... MOV.W   &0x712, &ADC_Right_Detector
     79               ADC_Channel = ZERO;
   \   000036   8243....     MOV.W   #0x0, &ADC_Channel
     80               break;
   \   00003A   0E3C         JMP     ??ADC10_ISR_0
     81               
     82               case Left_Detector:
     83               ADC10MCTL0 = ADC10INCH_1; //  channel A1
   \                     ??ADC10_ISR_3:
   \   00003C   92430A07     MOV.W   #0x1, &0x70a
     84               ADC_Left_Detector = ADC10MEM0; // Read Channel A1
   \   000040   92421207.... MOV.W   &0x712, &ADC_Left_Detector
     85               ADC_Channel = ZERO;
   \   000046   8243....     MOV.W   #0x0, &ADC_Channel
     86               break;
   \   00004A   063C         JMP     ??ADC10_ISR_0
     87               
     88               case Thumbwheel:
     89               ADC10MCTL0 = ADC10INCH_3; // Next channel A0
   \                     ??ADC10_ISR_4:
   \   00004C   B24003000A07 MOV.W   #0x3, &0x70a
     90               ADC_Thumb = ADC10MEM0; // Read Channel A3
   \   000052   92421207.... MOV.W   &0x712, &ADC_Thumb
     91               //ADC_Channel = ZERO;
     92               break;
     93               
     94               /*case CHANNEL_A10:
     95               ADC10MCTL0 = ADC10INCH_10; // Next channel A10
     96               ADC_Temp = ADC10MEM0; // Read Channel A10
     97               ADC_Channel++;
     98               break;
     99               
    100               case CHANNEL_A11:
    101               ADC10MCTL0 = ADC10INCH_0; // Next channel A0
    102               ADC_Bat = ADC10MEM0; // Read Channel A11
    103               ADC_Channel= ZERO;
    104               break;*/
    105               
    106               default: break;
    107               }
    108             ADC10CTL0 |= ADC10ENC | ADC10SC; // Start next sample.
   \                     ??ADC10_ISR_0:
   \   000058   B2D003000007 BIS.W   #0x3, &0x700
    109           default: break;
    110             }
    111          }
   \                     ??ADC10_ISR_1:
   \   00005E   3F41         POP.W   R15
   \   000060   0013         RETI
   \   000062                REQUIRE _A_ADC10CTL0_L
   \   000062                REQUIRE _A_ADC10MCTL0_L
   \   000062                REQUIRE _A_ADC10MEM0_L
   \   000062                REQUIRE _A_ADC10IV_L
    112          //-----------------------------------------------------------------------------
    113          
    114          //------------------------------------------------------------------------------
    115          #pragma vector=USCI_A1_VECTOR

   \                                 In  segment ISR_CODE, align 2
    116          __interrupt void USCI_A1_ISR(void){
   \                     USCI_A1_ISR:
   \   000000   1F15         PUSHM.W #0x2, R15
    117          /*******************************************************************************
    118          *        Author: Steffon Brigman
    119          *        Date:   October 2015
    120          *        Description: This function is the transmit and receive interrupt for UART
    121          *        Built with IAR Embedded Workbench Version: V7.0.5/W32 (6.10.5)
    122          *
    123          *        Function name: USCI_A1_ISR
    124          *        Passed : No variables passed 
    125          *        Returned: no values returned 
    126          *        Globlas: temp, cpu_rx_ring_wr
    127          *******************************************************************************/
    128           unsigned int temp;
    129           switch(__even_in_range(UCA1IV,UART_MAX)){
   \   000002   1E42FE05     MOV.W   &0x5fe, R14
   \   000006   E00E         ADDA    R14, PC
   \                     `?<Jumptable for USCI_A1_ISR>_0`:
   \   000008   123C         JMP     ??USCI_A1_ISR_2
   \   00000A   033C         JMP     ??USCI_A1_ISR_3
   \   00000C   103C         JMP     ??USCI_A1_ISR_2
   \   00000E   0F3C         JMP     ??USCI_A1_ISR_2
   \   000010   0E3C         JMP     ??USCI_A1_ISR_2
    130           case ZERO: // Vector 0 - no interrupt
    131           break;
    132           case RECEIVE: // Vector 2 – RXIFG
    133             temp = cpu_rx_ring_wr;
   \                     ??USCI_A1_ISR_3:
   \   000012   1F42....     MOV.W   &cpu_rx_ring_wr, R15
    134             CPU_Char_Rx[temp] = UCA1RXBUF; // RX -> CPU_Char_Rx character
   \   000016   1E42EC05     MOV.W   &0x5ec, R14
   \   00001A   CF4E....     MOV.B   R14, CPU_Char_Rx(R15)
    135             if (++cpu_rx_ring_wr >= (RING_8)){
   \   00001E   9253....     ADD.W   #0x1, &cpu_rx_ring_wr
   \   000022   B2900A00.... CMP.W   #0xa, &cpu_rx_ring_wr
   \   000028   0228         JNC     ??USCI_A1_ISR_2
    136             cpu_rx_ring_wr = BEGINNING; // Circular buffer back to beginning
   \   00002A   8243....     MOV.W   #0x0, &cpu_rx_ring_wr
    137             }
    138           break;
    139           case TRANSMIT: // Vector 4 – TXIFG
    140          // Code for Transmit
    141           break;
    142           default: break;
    143           }
    144          }
   \                     ??USCI_A1_ISR_2:
   \   00002E   1E17         POPM.W  #0x2, R15
   \   000030   0013         RETI
   \   000032                REQUIRE _A_UCA1RXBUF_L
   \   000032                REQUIRE UCA1IV

   \                                 In  segment INTVEC, offset 0x56, root
   \                     `??USCI_A1_ISR::??INTVEC 86`:
   \   000056   ....         DC16    USCI_A1_ISR

   \                                 In  segment INTVEC, offset 0x5a, root
   \                     `??Timer0_A0_ISR::??INTVEC 90`:
   \   00005A   ....         DC16    Timer0_A0_ISR

   \                                 In  segment INTVEC, offset 0x5c, root
   \                     `??ADC10_ISR::??INTVEC 92`:
   \   00005C   ....         DC16    ADC10_ISR
    145          //------------------------------------------------------------------------------

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      6   ADC10_ISR
     12   Timer0_A0_ISR
       12   -> Display_Process
      8   USCI_A1_ISR


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      98  ADC10_ISR
       2  ADC10_ISR::??INTVEC 92
       2  TA0CCR0
      52  Timer0_A0_ISR
       2  Timer0_A0_ISR::??INTVEC 90
       2  UCA1IV
      50  USCI_A1_ISR
       2  USCI_A1_ISR::??INTVEC 86
       2  _A_ADC10CTL0_L
       2  _A_ADC10IV_L
       2  _A_ADC10MCTL0_L
       2  _A_ADC10MEM0_L
       2  _A_PJOUT_L
       2  _A_UCA1RXBUF_L

 
  16 bytes in segment DATA16_AN
   6 bytes in segment INTVEC
 200 bytes in segment ISR_CODE
 
 200 bytes of CODE  memory
   0 bytes of CONST memory (+  6 bytes shared)
   0 bytes of DATA  memory (+ 16 bytes shared)

Errors: none
Warnings: none
