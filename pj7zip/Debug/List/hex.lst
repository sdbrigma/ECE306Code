###############################################################################
#
# IAR C/C++ Compiler V6.30.2.940/W32 for MSP430           17/Nov/2015  02:50:25
# Copyright 1996-2015 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for Texas Instruments MSP430, 8K KickStart Edition 6.30
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  
#        \\vmware-host\Shared Folders\Desktop\ECE306Code\pj7zip\hex.c
#    Command line  =  
#        "\\vmware-host\Shared Folders\Desktop\ECE306Code\pj7zip\hex.c" -lC
#        "\\vmware-host\Shared Folders\Desktop\ECE306Code\pj7zip\Debug\List\"
#        -o "\\vmware-host\Shared Folders\Desktop\ECE306Code\pj7zip\Debug\Obj\"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa --debug
#        -D__MSP430FR5739__ -e --double=32 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.2\430\lib\dlib\dl430xlsfn.h"
#        --core=430X --data_model=small -On --multiplier=32
#        --hw_workaround=CPU40 --code_model=large
#    List file     =  
#        \\vmware-host\Shared
#        Folders\Desktop\ECE306Code\pj7zip\Debug\List\hex.lst
#    Object file   =  
#        \\vmware-host\Shared
#        Folders\Desktop\ECE306Code\pj7zip\Debug\Obj\hex.r43
#
###############################################################################

\\vmware-host\Shared Folders\Desktop\ECE306Code\pj7zip\hex.c
      1          //******************************************************************************
      2          //
      3          //  Description: This file contains the hex conversion and display routine
      4          //
      5          //
      6          //  Steffon Brigman
      7          //  Sept 2015
      8          //  Built with IAR Embedded Workbench Version: V4.10A/W32 (6.30.3)
      9          //******************************************************************************
     10          
     11          //Points to Header files for Preprocessing
     12          #include  "msp430.h"
     13          #include  "functions.h"
     14          #include  "macros.h"
     15          

   \                                 In  segment CODE, align 2
     16          void Display_ADC (void){
   \                     Display_ADC:
   \   000000   1B15         PUSHM.W #0x2, R11
     17          //******************************************************************************
     18          //
     19          //  Description: This file contains the hex conversion and display routine with
     20          //  relation to the ADC
     21          //
     22          //  Steffon Brigman
     23          //  Sept 2015
     24          //  Built with IAR Embedded Workbench Version: V4.10A/W32 (6.30.3)
     25          //
     26          // Globals: ADC_Thumb, ADC_Right_Detector, ADC_Left_Detector
     27          // adc_RD_Enable, adc_LD_Enable
     28          //
     29          // Passed:
     30          //
     31          // Local: tmpWork, ADCtemp
     32          //
     33          // Return: VOID
     34          //
     35          //****************************************************************************** 
     36            
     37            // Initialize
     38            unsigned int ADCtemp = INITIAL;
   \   000002   0B43         MOV.W   #0x0, R11
     39            unsigned int tmpWork = INITIAL;
   \   000004   0A43         MOV.W   #0x0, R10
     40              
     41            if(adc_RD_Enable)ADCtemp = ADC_Right_Detector;        // HEX value to read
   \   000006   C293....     CMP.B   #0x0, &adc_RD_Enable
   \   00000A   0224         JEQ     ??Display_ADC_0
   \   00000C   1B42....     MOV.W   &ADC_Right_Detector, R11
     42            if(adc_LD_Enable)ADCtemp = ADC_Left_Detector;         // HEX value to read 
   \                     ??Display_ADC_0:
   \   000010   C293....     CMP.B   #0x0, &adc_LD_Enable
   \   000014   0224         JEQ     ??Display_ADC_1
   \   000016   1B42....     MOV.W   &ADC_Left_Detector, R11
     43            
     44            tmpWork = ADCtemp;                                    // Temporary Operator
   \                     ??Display_ADC_1:
   \   00001A   0A4B         MOV.W   R11, R10
     45            
     46            // First Nibble
     47            tmpWork = tmpWork & FIRST_NIBBLE;                     // Work with least significant nibble
   \   00001C   3AF00F00     AND.W   #0xf, R10
     48            if (tmpWork >= LETTER_START) {
   \   000020   3A900A00     CMP.W   #0xa, R10
   \   000024   0328         JNC     ??Display_ADC_2
     49              tmpWork += LETTER_OP;                               // Code for 0xA - 0xF
   \   000026   3A503700     ADD.W   #0x37, R10
   \   00002A   023C         JMP     ??Display_ADC_3
     50            }
     51            else {
     52              tmpWork |= NUMBER_OP;                               // Code for 0x0 - 0x9
   \                     ??Display_ADC_2:
   \   00002C   3AD03000     BIS.W   #0x30, R10
     53            }
     54            
     55            if(adc_RD_Enable)display_3[LINE_POS_L8] = tmpWork;    // Display character
   \                     ??Display_ADC_3:
   \   000030   C293....     CMP.B   #0x0, &adc_RD_Enable
   \   000034   0424         JEQ     ??Display_ADC_4
   \   000036   1F42....     MOV.W   &display_3, R15
   \   00003A   CF4A0800     MOV.B   R10, 0x8(R15)
     56            if(adc_LD_Enable)display_2[LINE_POS_L8] = tmpWork;    // Display character
   \                     ??Display_ADC_4:
   \   00003E   C293....     CMP.B   #0x0, &adc_LD_Enable
   \   000042   0424         JEQ     ??Display_ADC_5
   \   000044   1F42....     MOV.W   &display_2, R15
   \   000048   CF4A0800     MOV.B   R10, 0x8(R15)
     57            
     58            // Second Nibble
     59            tmpWork = ADCtemp;                                    // Use original value
   \                     ??Display_ADC_5:
   \   00004C   0A4B         MOV.W   R11, R10
     60            tmpWork &= SECOND_NIBBLE;                             // Second nibble
   \   00004E   3AF0F000     AND.W   #0xf0, R10
     61            tmpWork >>= SHIFT_4;                                  // Shift to lowest order bits
   \   000052   5A0F         RRUM.W  #0x4, R10
     62            if (tmpWork >= LETTER_START) {
   \   000054   3A900A00     CMP.W   #0xa, R10
   \   000058   0328         JNC     ??Display_ADC_6
     63              tmpWork += LETTER_OP;                               // Code for 0xA - 0xF
   \   00005A   3A503700     ADD.W   #0x37, R10
   \   00005E   023C         JMP     ??Display_ADC_7
     64            }
     65            else {
     66              tmpWork |= NUMBER_OP;                               // Code for 0x0 - 0x9
   \                     ??Display_ADC_6:
   \   000060   3AD03000     BIS.W   #0x30, R10
     67            }
     68            if(adc_RD_Enable)display_3[LINE_POS_L7] = tmpWork;    // Display character
   \                     ??Display_ADC_7:
   \   000064   C293....     CMP.B   #0x0, &adc_RD_Enable
   \   000068   0424         JEQ     ??Display_ADC_8
   \   00006A   1F42....     MOV.W   &display_3, R15
   \   00006E   CF4A0700     MOV.B   R10, 0x7(R15)
     69            if(adc_LD_Enable)display_2[LINE_POS_L7] = tmpWork;    // Display character
   \                     ??Display_ADC_8:
   \   000072   C293....     CMP.B   #0x0, &adc_LD_Enable
   \   000076   0424         JEQ     ??Display_ADC_9
   \   000078   1F42....     MOV.W   &display_2, R15
   \   00007C   CF4A0700     MOV.B   R10, 0x7(R15)
     70            
     71            // Third Nibble
     72            tmpWork = ADCtemp;                                    // Use original value
   \                     ??Display_ADC_9:
   \   000080   0A4B         MOV.W   R11, R10
     73            tmpWork &= THIRD_NIBBLE;                              // Third nibble
   \   000082   3AF0000F     AND.W   #0xf00, R10
     74            tmpWork >>= SHIFT_8;                                  // Shift to lowest order bits
   \   000086   8A10         SWPB    R10
   \   000088   3AF0FF00     AND.W   #0xff, R10
     75            if (tmpWork >= LETTER_START) {
   \   00008C   3A900A00     CMP.W   #0xa, R10
   \   000090   0328         JNC     ??Display_ADC_10
     76              tmpWork += LETTER_OP;                               // Code for 0xA - 0xF
   \   000092   3A503700     ADD.W   #0x37, R10
   \   000096   023C         JMP     ??Display_ADC_11
     77            }
     78            else {
     79              tmpWork |= NUMBER_OP;                               // Code for 0x0 - 0x9
   \                     ??Display_ADC_10:
   \   000098   3AD03000     BIS.W   #0x30, R10
     80            }
     81            if(adc_RD_Enable)display_3[LINE_POS_L6] = tmpWork;    // Display character
   \                     ??Display_ADC_11:
   \   00009C   C293....     CMP.B   #0x0, &adc_RD_Enable
   \   0000A0   0424         JEQ     ??Display_ADC_12
   \   0000A2   1F42....     MOV.W   &display_3, R15
   \   0000A6   CF4A0600     MOV.B   R10, 0x6(R15)
     82            if(adc_LD_Enable)display_2[LINE_POS_L6] = tmpWork;    // Display character
   \                     ??Display_ADC_12:
   \   0000AA   C293....     CMP.B   #0x0, &adc_LD_Enable
   \   0000AE   0424         JEQ     ??Display_ADC_13
   \   0000B0   1F42....     MOV.W   &display_2, R15
   \   0000B4   CF4A0600     MOV.B   R10, 0x6(R15)
     83          
     84            
     85            // Push changes to display
     86            Display_Process();
   \                     ??Display_ADC_13:
   \   0000B8   ........     CALLA   #Display_Process
     87          }
   \   0000BC   1A17         POPM.W  #0x2, R11
   \   0000BE   1001         RETA
     88          

   \                                 In  segment CODE, align 2
     89          void Display_Thumb (void){
   \                     Display_Thumb:
   \   000000   1B15         PUSHM.W #0x2, R11
     90          //******************************************************************************
     91          //
     92          //  Description: This file contains the hex conversion and display routine with
     93          //  relation to the ADC
     94          //
     95          //  Steffon Brigman
     96          //  Sept 2015
     97          //  Built with IAR Embedded Workbench Version: V4.10A/W32 (6.30.3)
     98          //
     99          // Globals: ADC_Thumb, ADC_Right_Detector, ADC_Left_Detector
    100          // adc_RD_Enable, adc_LD_Enable
    101          //
    102          // Passed:
    103          //
    104          // Local: tmpWork, ADCtemp
    105          //
    106          // Return: VOID
    107          //
    108          //****************************************************************************** 
    109            
    110            // Initialize
    111            unsigned int ADCtemp = INITIAL;
   \   000002   0B43         MOV.W   #0x0, R11
    112            unsigned int tmpWork = INITIAL;
   \   000004   0A43         MOV.W   #0x0, R10
    113              
    114            ADCtemp = ADC_Thumb;        // HEX value to read
   \   000006   1B42....     MOV.W   &ADC_Thumb, R11
    115            
    116            tmpWork = ADCtemp;                                    // Temporary Operator
   \   00000A   0A4B         MOV.W   R11, R10
    117            
    118            // First Nibble
    119            tmpWork = tmpWork & FIRST_NIBBLE;                     // Work with least significant nibble
   \   00000C   3AF00F00     AND.W   #0xf, R10
    120            if (tmpWork >= LETTER_START) {
   \   000010   3A900A00     CMP.W   #0xa, R10
   \   000014   0328         JNC     ??Display_Thumb_0
    121              tmpWork += LETTER_OP;                               // Code for 0xA - 0xF
   \   000016   3A503700     ADD.W   #0x37, R10
   \   00001A   023C         JMP     ??Display_Thumb_1
    122            }
    123            else {
    124              tmpWork |= NUMBER_OP;                               // Code for 0x0 - 0x9
   \                     ??Display_Thumb_0:
   \   00001C   3AD03000     BIS.W   #0x30, R10
    125            }
    126            
    127            display_2[LINE_POS_L8] = tmpWork;    // Display character
   \                     ??Display_Thumb_1:
   \   000020   1F42....     MOV.W   &display_2, R15
   \   000024   CF4A0800     MOV.B   R10, 0x8(R15)
    128            
    129            // Second Nibble
    130            tmpWork = ADCtemp;                                    // Use original value
   \   000028   0A4B         MOV.W   R11, R10
    131            tmpWork &= SECOND_NIBBLE;                             // Second nibble
   \   00002A   3AF0F000     AND.W   #0xf0, R10
    132            tmpWork >>= SHIFT_4;                                  // Shift to lowest order bits
   \   00002E   5A0F         RRUM.W  #0x4, R10
    133            if (tmpWork >= LETTER_START) {
   \   000030   3A900A00     CMP.W   #0xa, R10
   \   000034   0328         JNC     ??Display_Thumb_2
    134              tmpWork += LETTER_OP;                               // Code for 0xA - 0xF
   \   000036   3A503700     ADD.W   #0x37, R10
   \   00003A   023C         JMP     ??Display_Thumb_3
    135            }
    136            else {
    137              tmpWork |= NUMBER_OP;                               // Code for 0x0 - 0x9
   \                     ??Display_Thumb_2:
   \   00003C   3AD03000     BIS.W   #0x30, R10
    138            }
    139            display_2[LINE_POS_L7] = tmpWork;    // Display character
   \                     ??Display_Thumb_3:
   \   000040   1F42....     MOV.W   &display_2, R15
   \   000044   CF4A0700     MOV.B   R10, 0x7(R15)
    140            
    141            // Third Nibble
    142            tmpWork = ADCtemp;                                    // Use original value
   \   000048   0A4B         MOV.W   R11, R10
    143            tmpWork &= THIRD_NIBBLE;                              // Third nibble
   \   00004A   3AF0000F     AND.W   #0xf00, R10
    144            tmpWork >>= SHIFT_8;                                  // Shift to lowest order bits
   \   00004E   8A10         SWPB    R10
   \   000050   3AF0FF00     AND.W   #0xff, R10
    145            if (tmpWork >= LETTER_START) {
   \   000054   3A900A00     CMP.W   #0xa, R10
   \   000058   0328         JNC     ??Display_Thumb_4
    146              tmpWork += LETTER_OP;                               // Code for 0xA - 0xF
   \   00005A   3A503700     ADD.W   #0x37, R10
   \   00005E   023C         JMP     ??Display_Thumb_5
    147            }
    148            else {
    149              tmpWork |= NUMBER_OP;                               // Code for 0x0 - 0x9
   \                     ??Display_Thumb_4:
   \   000060   3AD03000     BIS.W   #0x30, R10
    150            }
    151            display_2[LINE_POS_L6] = tmpWork;    // Display character
   \                     ??Display_Thumb_5:
   \   000064   1F42....     MOV.W   &display_2, R15
   \   000068   CF4A0600     MOV.B   R10, 0x6(R15)
    152          
    153            // Push changes to display
    154            Display_Process();
   \   00006C   ........     CALLA   #Display_Process
    155          }
   \   000070   1A17         POPM.W  #0x2, R11
   \   000072   1001         RETA
    156          

   \                                 In  segment CODE, align 2
    157          unsigned int intToHex (unsigned int intTemp){
   \                     intToHex:
   \   000000   0F4C         MOV.W   R12, R15
    158          //******************************************************************************
    159          //
    160          //  Description: This functions implements the integer to ASCII conversion
    161          //
    162          //  Steffon Brigman
    163          //  Sept 2015
    164          //  Built with IAR Embedded Workbench Version: V4.10A/W32 (6.30.3)
    165          //
    166          // Globals: 
    167          //
    168          // Passed: conver
    169          //
    170          // Local: tmpHEX, tmpReturn
    171          //
    172          // Return: VOID
    173          //
    174          //****************************************************************************** 
    175            
    176            // Initialize
    177            unsigned int tmpHEX = INITIAL;
   \   000002   0E43         MOV.W   #0x0, R14
    178            unsigned int tmpReturn = INITIAL;
   \   000004   0C43         MOV.W   #0x0, R12
    179            
    180            tmpHEX = intTemp;                                    // Temporary Operator
   \   000006   0E4F         MOV.W   R15, R14
    181            
    182            // First Nibble
    183            tmpHEX &= FIRST_NYBL;                     // Work with least significant nibble
   \   000008   3EF00F00     AND.W   #0xf, R14
    184            if (tmpHEX >= LETTER_START) {
   \   00000C   3E900A00     CMP.W   #0xa, R14
   \   000010   0328         JNC     ??intToHex_0
    185              tmpHEX += LETTER_OP;                               // Code for 0xA - 0xF
   \   000012   3E503700     ADD.W   #0x37, R14
   \   000016   023C         JMP     ??intToHex_1
    186            }
    187            else {
    188              tmpHEX |= NUMBER_OP;                               // Code for 0x0 - 0x9
   \                     ??intToHex_0:
   \   000018   3ED03000     BIS.W   #0x30, R14
    189            }
    190            
    191            tmpReturn |= tmpHEX;    // Display character
   \                     ??intToHex_1:
   \   00001C   0CDE         BIS.W   R14, R12
    192            
    193            // Second Nibble
    194            tmpHEX = intTemp;                                    // Use original value
   \   00001E   0E4F         MOV.W   R15, R14
    195            tmpHEX &= SECOND_NYBL;                             // Second nibble
   \   000020   3EF0F000     AND.W   #0xf0, R14
    196            tmpHEX >>= SHIFT_4;                                  // Shift to lowest order bits
   \   000024   5E0F         RRUM.W  #0x4, R14
    197            if (tmpHEX >= LETTER_START) {
   \   000026   3E900A00     CMP.W   #0xa, R14
   \   00002A   0328         JNC     ??intToHex_2
    198              tmpHEX += LETTER_OP;                               // Code for 0xA - 0xF
   \   00002C   3E503700     ADD.W   #0x37, R14
   \   000030   023C         JMP     ??intToHex_3
    199            }
    200            else {
    201              tmpHEX |= NUMBER_OP;                               // Code for 0x0 - 0x9
   \                     ??intToHex_2:
   \   000032   3ED03000     BIS.W   #0x30, R14
    202            }
    203            tmpHEX <<= SHIFT_4;
   \                     ??intToHex_3:
   \   000036   5E0E         RLAM.W  #0x4, R14
    204            tmpReturn |= tmpHEX;    // Display character
   \   000038   0CDE         BIS.W   R14, R12
    205           
    206            tmpReturn &= FIRST_BYTE;
   \   00003A   3CF0FF00     AND.W   #0xff, R12
    207            
    208            return tmpReturn;
   \   00003E   1001         RETA
    209           
    210          }
    211          

   \                                 In  segment CODE, align 2
    212          void hexToInt (unsigned int hexTemp){
   \                     hexToInt:
    213          //******************************************************************************
    214          //
    215          //  Description: This functions implements the ASCII display
    216          //
    217          //  Steffon Brigman
    218          //  Sept 2015
    219          //  Built with IAR Embedded Workbench Version: V4.10A/W32 (6.30.3)
    220          //
    221          // Globals: tempCount, tempDisplay[], tempCount
    222          //
    223          // Passed: hexTemp
    224          //
    225          // Local: tmpHEX, intTemp
    226          //
    227          // Return: VOID
    228          //
    229          //****************************************************************************** 
    230            
    231            tempCount = hexTemp;
   \   000000   824C....     MOV.W   R12, &tempCount
    232            
    233            tempDisplay[SW_SEL_0] = NUMBER_OP;
   \   000004   B2403000.... MOV.W   #0x30, &tempDisplay
    234            tempDisplay[SW_SEL_1] = NUMBER_OP;
   \   00000A   B2403000.... MOV.W   #0x30, &tempDisplay + 2
    235            tempDisplay[SW_SEL_2] = NUMBER_OP;
   \   000010   B2403000.... MOV.W   #0x30, &tempDisplay + 4
    236            tempDisplay[SW_SEL_3] = NUMBER_OP;
   \   000016   B2403000.... MOV.W   #0x30, &tempDisplay + 6
    237            tempDisplay[SW_SEL_4] = NUMBER_OP;
   \   00001C   B2403000.... MOV.W   #0x30, &tempDisplay + 8
    238            tempDisplay[SW_SEL_5] = NUMBER_OP;
   \   000022   B2403000.... MOV.W   #0x30, &tempDisplay + 10
    239            tempDisplay[SW_SEL_6] = NUMBER_OP;
   \   000028   B2403000.... MOV.W   #0x30, &tempDisplay + 12
    240            tempDisplay[SW_SEL_7] = NUMBER_OP;
   \   00002E   B2403000.... MOV.W   #0x30, &tempDisplay + 14
    241            tempDisplay[SW_SEL_8] = NUMBER_OP;
   \   000034   B2403000.... MOV.W   #0x30, &tempDisplay + 16
    242            tempDisplay[SW_SEL_9] = NUMBER_OP;
   \   00003A   B2403000.... MOV.W   #0x30, &tempDisplay + 18
    243            
    244            
    245            while (tempCount > INITIAL) {
   \                     ??hexToInt_0:
   \   000040   8293....     CMP.W   #0x0, &tempCount
   \   000044   B524         JEQ     ??hexToInt_1
    246              
    247              if (tempDisplay[SW_SEL_0] > NUMBER_MAX) {
   \   000046   B2903A00.... CMP.W   #0x3a, &tempDisplay
   \   00004C   0528         JNC     ??hexToInt_2
    248                   tempDisplay[SW_SEL_1]++;
   \   00004E   9253....     ADD.W   #0x1, &tempDisplay + 2
    249                   tempDisplay[SW_SEL_0] = NUMBER_OP;
   \   000052   B2403000.... MOV.W   #0x30, &tempDisplay
    250                 }    
    251                if (tempDisplay[SW_SEL_1] == NUMBER_MAX) {
   \                     ??hexToInt_2:
   \   000058   B2903900.... CMP.W   #0x39, &tempDisplay + 2
   \   00005E   0520         JNE     ??hexToInt_3
    252                   tempDisplay[SW_SEL_2]++;
   \   000060   9253....     ADD.W   #0x1, &tempDisplay + 4
    253                   tempDisplay[SW_SEL_1] = NUMBER_OP;
   \   000064   B2403000.... MOV.W   #0x30, &tempDisplay + 2
    254                 }
    255                 if (tempDisplay[SW_SEL_2] == NUMBER_MAX) {
   \                     ??hexToInt_3:
   \   00006A   B2903900.... CMP.W   #0x39, &tempDisplay + 4
   \   000070   0520         JNE     ??hexToInt_4
    256                   tempDisplay[SW_SEL_3]++;
   \   000072   9253....     ADD.W   #0x1, &tempDisplay + 6
    257                   tempDisplay[SW_SEL_2] = NUMBER_OP;
   \   000076   B2403000.... MOV.W   #0x30, &tempDisplay + 4
    258                 }
    259                 if (tempDisplay[SW_SEL_3] == NUMBER_MAX) {
   \                     ??hexToInt_4:
   \   00007C   B2903900.... CMP.W   #0x39, &tempDisplay + 6
   \   000082   0520         JNE     ??hexToInt_5
    260                   tempDisplay[SW_SEL_4]++;
   \   000084   9253....     ADD.W   #0x1, &tempDisplay + 8
    261                   tempDisplay[SW_SEL_3] = NUMBER_OP;
   \   000088   B2403000.... MOV.W   #0x30, &tempDisplay + 6
    262                 }
    263                 if (tempDisplay[SW_SEL_5] == NUMBER_MAX) {
   \                     ??hexToInt_5:
   \   00008E   B2903900.... CMP.W   #0x39, &tempDisplay + 10
   \   000094   0520         JNE     ??hexToInt_6
    264                   tempDisplay[SW_SEL_6]++;
   \   000096   9253....     ADD.W   #0x1, &tempDisplay + 12
    265                   tempDisplay[SW_SEL_5] = NUMBER_OP;
   \   00009A   B2403000.... MOV.W   #0x30, &tempDisplay + 10
    266                 }
    267                 if (tempDisplay[SW_SEL_6] == NUMBER_MAX) {
   \                     ??hexToInt_6:
   \   0000A0   B2903900.... CMP.W   #0x39, &tempDisplay + 12
   \   0000A6   0520         JNE     ??hexToInt_7
    268                   tempDisplay[SW_SEL_7]++;
   \   0000A8   9253....     ADD.W   #0x1, &tempDisplay + 14
    269                   tempDisplay[SW_SEL_6] = NUMBER_OP;
   \   0000AC   B2403000.... MOV.W   #0x30, &tempDisplay + 12
    270                 }
    271                 if (tempDisplay[SW_SEL_7] == NUMBER_MAX) {
   \                     ??hexToInt_7:
   \   0000B2   B2903900.... CMP.W   #0x39, &tempDisplay + 14
   \   0000B8   0520         JNE     ??hexToInt_8
    272                   tempDisplay[SW_SEL_8]++;
   \   0000BA   9253....     ADD.W   #0x1, &tempDisplay + 16
    273                   tempDisplay[SW_SEL_7] = NUMBER_OP;
   \   0000BE   B2403000.... MOV.W   #0x30, &tempDisplay + 14
    274                 }
    275                 if (tempDisplay[SW_SEL_8] == NUMBER_MAX) {
   \                     ??hexToInt_8:
   \   0000C4   B2903900.... CMP.W   #0x39, &tempDisplay + 16
   \   0000CA   0520         JNE     ??hexToInt_9
    276                   tempDisplay[SW_SEL_9]++;
   \   0000CC   9253....     ADD.W   #0x1, &tempDisplay + 18
    277                   tempDisplay[SW_SEL_8] = NUMBER_OP;
   \   0000D0   B2403000.... MOV.W   #0x30, &tempDisplay + 16
    278                 }
    279                 if (tempDisplay[SW_SEL_9] == NUMBER_MAX) {
   \                     ??hexToInt_9:
   \   0000D6   B2903900.... CMP.W   #0x39, &tempDisplay + 18
   \   0000DC   3220         JNE     ??hexToInt_10
    280                   display_3[SW_SEL_0] = NUMBER_OP;
   \   0000DE   1F42....     MOV.W   &display_3, R15
   \   0000E2   FF4030000000 MOV.B   #0x30, 0(R15)
    281                   display_3[SW_SEL_1] = NUMBER_OP;
   \   0000E8   1F42....     MOV.W   &display_3, R15
   \   0000EC   FF4030000100 MOV.B   #0x30, 0x1(R15)
    282                   display_3[SW_SEL_2] = NUMBER_OP;
   \   0000F2   1F42....     MOV.W   &display_3, R15
   \   0000F6   FF4030000200 MOV.B   #0x30, 0x2(R15)
    283                   display_3[SW_SEL_3] = NUMBER_OP;
   \   0000FC   1F42....     MOV.W   &display_3, R15
   \   000100   FF4030000300 MOV.B   #0x30, 0x3(R15)
    284                   display_3[SW_SEL_4] = NUMBER_OP;
   \   000106   1F42....     MOV.W   &display_3, R15
   \   00010A   FF4030000400 MOV.B   #0x30, 0x4(R15)
    285                   display_3[SW_SEL_5] = NUMBER_OP;
   \   000110   1F42....     MOV.W   &display_3, R15
   \   000114   FF4030000500 MOV.B   #0x30, 0x5(R15)
    286                   display_3[SW_SEL_6] = NUMBER_OP;
   \   00011A   1F42....     MOV.W   &display_3, R15
   \   00011E   FF4030000600 MOV.B   #0x30, 0x6(R15)
    287                   display_3[SW_SEL_7] = NUMBER_OP;
   \   000124   1F42....     MOV.W   &display_3, R15
   \   000128   FF4030000700 MOV.B   #0x30, 0x7(R15)
    288                   display_3[SW_SEL_8] = NUMBER_OP;
   \   00012E   1F42....     MOV.W   &display_3, R15
   \   000132   FF4030000800 MOV.B   #0x30, 0x8(R15)
    289                   display_3[SW_SEL_9] = NUMBER_OP;
   \   000138   1F42....     MOV.W   &display_3, R15
   \   00013C   FF4030000900 MOV.B   #0x30, 0x9(R15)
    290                 }
    291              
    292                  display_3[SW_SEL_0] = tempDisplay[SW_SEL_9];
   \                     ??hexToInt_10:
   \   000142   1F42....     MOV.W   &display_3, R15
   \   000146   DF42....0000 MOV.B   &tempDisplay + 18, 0(R15)
    293                  display_3[SW_SEL_1] = tempDisplay[SW_SEL_8];
   \   00014C   1F42....     MOV.W   &display_3, R15
   \   000150   DF42....0100 MOV.B   &tempDisplay + 16, 0x1(R15)
    294                  display_3[SW_SEL_2] = tempDisplay[SW_SEL_7];
   \   000156   1F42....     MOV.W   &display_3, R15
   \   00015A   DF42....0200 MOV.B   &tempDisplay + 14, 0x2(R15)
    295                  display_3[SW_SEL_3] = tempDisplay[SW_SEL_6];
   \   000160   1F42....     MOV.W   &display_3, R15
   \   000164   DF42....0300 MOV.B   &tempDisplay + 12, 0x3(R15)
    296                  display_3[SW_SEL_4] = tempDisplay[SW_SEL_5];
   \   00016A   1F42....     MOV.W   &display_3, R15
   \   00016E   DF42....0400 MOV.B   &tempDisplay + 10, 0x4(R15)
    297                  display_3[SW_SEL_5] = tempDisplay[SW_SEL_4];
   \   000174   1F42....     MOV.W   &display_3, R15
   \   000178   DF42....0500 MOV.B   &tempDisplay + 8, 0x5(R15)
    298                  display_3[SW_SEL_6] = tempDisplay[SW_SEL_3];
   \   00017E   1F42....     MOV.W   &display_3, R15
   \   000182   DF42....0600 MOV.B   &tempDisplay + 6, 0x6(R15)
    299                  display_3[SW_SEL_7] = tempDisplay[SW_SEL_2];
   \   000188   1F42....     MOV.W   &display_3, R15
   \   00018C   DF42....0700 MOV.B   &tempDisplay + 4, 0x7(R15)
    300                  display_3[SW_SEL_8] = tempDisplay[SW_SEL_1];
   \   000192   1F42....     MOV.W   &display_3, R15
   \   000196   DF42....0800 MOV.B   &tempDisplay + 2, 0x8(R15)
    301                  display_3[SW_SEL_9] = tempDisplay[SW_SEL_0];
   \   00019C   1F42....     MOV.W   &display_3, R15
   \   0001A0   DF42....0900 MOV.B   &tempDisplay, 0x9(R15)
    302                  
    303              tempDisplay[SW_SEL_0]++;
   \   0001A6   9253....     ADD.W   #0x1, &tempDisplay
    304              tempCount--;
   \   0001AA   B253....     ADD.W   #0xffff, &tempCount
   \   0001AE   483F         JMP     ??hexToInt_0
    305              
    306            }
    307           
    308          }
   \                     ??hexToInt_1:
   \   0001B0   1001         RETA

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      8   Display_ADC
        8   -> Display_Process
      8   Display_Thumb
        8   -> Display_Process
      4   hexToInt
      4   intToHex


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
     192  Display_ADC
     116  Display_Thumb
     434  hexToInt
      64  intToHex

 
 806 bytes in segment CODE
 
 806 bytes of CODE memory

Errors: none
Warnings: none
