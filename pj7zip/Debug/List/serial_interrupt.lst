###############################################################################
#
# IAR C/C++ Compiler V6.30.2.940/W32 for MSP430           17/Nov/2015  02:50:40
# Copyright 1996-2015 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for Texas Instruments MSP430, 8K KickStart Edition 6.30
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  
#        \\vmware-host\Shared
#        Folders\Desktop\ECE306Code\pj7zip\serial_interrupt.c
#    Command line  =  
#        "\\vmware-host\Shared
#        Folders\Desktop\ECE306Code\pj7zip\serial_interrupt.c" -lC
#        "\\vmware-host\Shared Folders\Desktop\ECE306Code\pj7zip\Debug\List\"
#        -o "\\vmware-host\Shared Folders\Desktop\ECE306Code\pj7zip\Debug\Obj\"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa --debug
#        -D__MSP430FR5739__ -e --double=32 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.2\430\lib\dlib\dl430xlsfn.h"
#        --core=430X --data_model=small -On --multiplier=32
#        --hw_workaround=CPU40 --code_model=large
#    List file     =  
#        \\vmware-host\Shared
#        Folders\Desktop\ECE306Code\pj7zip\Debug\List\serial_interrupt.lst
#    Object file   =  
#        \\vmware-host\Shared
#        Folders\Desktop\ECE306Code\pj7zip\Debug\Obj\serial_interrupt.r43
#
###############################################################################

\\vmware-host\Shared Folders\Desktop\ECE306Code\pj7zip\serial_interrupt.c
      1          //******************************************************************************
      2          //
      3          //  Description: Handles eUSCI_A interrupts
      4          //
      5          //
      6          //  Steffon Brigman
      7          //  Nov 2015
      8          //  Built with IAR Embedded Workbench Version: V4.10A/W32 (6.30.3)
      9          //******************************************************************************
     10          
     11          //Points to Header files for Preprocessing
     12          #include  "msp430.h"

   \                                 In  segment DATA16_AN, at 0x5cc
   \   union <unnamed> _A_UCA0RXBUF_L
   \                     _A_UCA0RXBUF_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x5de
   \   unsigned short volatile UCA0IV
   \                     UCA0IV:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x5ec
   \   union <unnamed> _A_UCA1RXBUF_L
   \                     _A_UCA1RXBUF_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x5fe
   \   unsigned short volatile UCA1IV
   \                     UCA1IV:
   \   000000                DS8 2
     13          #include  "functions.h"
     14          #include  "macros.h"
     15          
     16          #pragma vector = USCI_A0_VECTOR

   \                                 In  segment ISR_CODE, align 2
     17          __interrupt void USCI_A0_ISR(void){
   \                     USCI_A0_ISR:
   \   000000   1F15         PUSHM.W #0x2, R15
     18          //******************************************************************************
     19          //
     20          //  Description: Handles eUSCI_A0 interrupts
     21          //
     22          //
     23          //  Steffon Brigman
     24          //  Nov 2015
     25          //  Built with IAR Embedded Workbench Version: V4.10A/W32 (6.30.3)
     26          //
     27          // Globals: rxRead RX_Char[WORD_LENGTH], receiveEnable
     28          //
     29          // Passed:
     30          //
     31          // Local: temp
     32          //
     33          // Return: VOID
     34          //
     35          //****************************************************************************** 
     36            unsigned int temp = INITIAL;
   \   000002   0F43         MOV.W   #0x0, R15
     37            switch(__even_in_range(UCA0IV, USCI_val8)) {
   \   000004   1E42DE05     MOV.W   &0x5de, R14
   \   000008   E00E         ADDA    R14, PC
   \                     `?<Jumptable for USCI_A0_ISR>_0`:
   \   00000A   163C         JMP     ??USCI_A0_ISR_2
   \   00000C   033C         JMP     ??USCI_A0_ISR_3
   \   00000E   143C         JMP     ??USCI_A0_ISR_2
   \   000010   133C         JMP     ??USCI_A0_ISR_2
   \   000012   123C         JMP     ??USCI_A0_ISR_2
     38            case SW_SEL_0:		//Vector 0 - No Interrupt
     39              break;
     40            case SW_SEL_2:		// Vector 2 - RXIFG
     41              // Code for Receive
     42              temp = rxRead;
   \                     ??USCI_A0_ISR_3:
   \   000014   1F42....     MOV.W   &rxRead, R15
     43              receiveEnable = TRUE;           // Tranmission received
   \   000018   D243....     MOV.B   #0x1, &receiveEnable
     44              RX_Char[temp] =  UCA0RXBUF;   // Store Transmission                    
   \   00001C   1E42CC05     MOV.W   &0x5cc, R14
   \   000020   CF4E....     MOV.B   R14, RX_Char(R15)
     45              if (++rxRead >= (SMALL_RING_SIZE)) {
   \   000024   1E42....     MOV.W   &rxRead, R14
   \   000028   1E53         ADD.W   #0x1, R14
   \   00002A   824E....     MOV.W   R14, &rxRead
   \   00002E   3E902800     CMP.W   #0x28, R14
   \   000032   0228         JNC     ??USCI_A0_ISR_2
     46                rxRead = INITIAL;             // Reset Index
   \   000034   8243....     MOV.W   #0x0, &rxRead
     47              }
     48              break;
     49            case SW_SEL_4:		// Vector 4 - TXIFG
     50              // Code for Transmit
     51              break;
     52            default: break;
     53            }
     54            
     55          }
   \                     ??USCI_A0_ISR_2:
   \   000038   1E17         POPM.W  #0x2, R15
   \   00003A   0013         RETI
   \   00003C                REQUIRE _A_UCA0RXBUF_L
   \   00003C                REQUIRE UCA0IV
     56          
     57          #pragma vector = USCI_A1_VECTOR

   \                                 In  segment ISR_CODE, align 2
     58          __interrupt void USCI_A1_ISR(void){
   \                     USCI_A1_ISR:
   \   000000   1F15         PUSHM.W #0x2, R15
     59          //******************************************************************************
     60          //
     61          //  Description: Handles eUSCI_A interrupts
     62          //
     63          //
     64          //  Steffon Brigman
     65          //  Nov 2015
     66          //  Built with IAR Embedded Workbench Version: V4.10A/W32 (6.30.3)
     67          //
     68          // Globals: rxRead RX_Char[WORD_LENGTH], receiveEnable
     69          //
     70          // Passed:
     71          //
     72          // Local: temp
     73          //
     74          // Return: VOID
     75          //
     76          //****************************************************************************** 
     77            unsigned int temp = INITIAL;
   \   000002   0F43         MOV.W   #0x0, R15
     78            switch(__even_in_range(UCA1IV, USCI_val8)) {
   \   000004   1E42FE05     MOV.W   &0x5fe, R14
   \   000008   E00E         ADDA    R14, PC
   \                     `?<Jumptable for USCI_A1_ISR>_0`:
   \   00000A   1D3C         JMP     ??USCI_A1_ISR_2
   \   00000C   033C         JMP     ??USCI_A1_ISR_4
   \   00000E   1B3C         JMP     ??USCI_A1_ISR_2
   \   000010   1A3C         JMP     ??USCI_A1_ISR_2
   \   000012   193C         JMP     ??USCI_A1_ISR_2
     79            case SW_SEL_0:		//Vector 0 - No Interrupt
     80              break;
     81            case SW_SEL_2:		// Vector 2 - RXIFG
     82              // Code for Receive
     83              temp = IOTRead;
   \                     ??USCI_A1_ISR_4:
   \   000014   1F42....     MOV.W   &IOTRead, R15
     84              IOT_RX[temp] =  UCA1RXBUF;   // Store Transmission 
   \   000018   1E42EC05     MOV.W   &0x5ec, R14
   \   00001C   CF4E....     MOV.B   R14, IOT_RX(R15)
     85              if (IOT_RX[temp] == '*') {
   \   000020   FF902A00.... CMP.B   #0x2a, IOT_RX(R15)
   \   000026   0520         JNE     ??USCI_A1_ISR_3
     86                IOTRead = INITIAL;
   \   000028   8243....     MOV.W   #0x0, &IOTRead
     87                IOT_RX[Pos0] = IOT_RX[temp];
   \   00002C   D24F........ MOV.B   IOT_RX(R15), &IOT_RX
     88              }
     89              if (++IOTRead >= (SMALL_RING_SIZE)) {
   \                     ??USCI_A1_ISR_3:
   \   000032   1E42....     MOV.W   &IOTRead, R14
   \   000036   1E53         ADD.W   #0x1, R14
   \   000038   824E....     MOV.W   R14, &IOTRead
   \   00003C   3E902800     CMP.W   #0x28, R14
   \   000040   0228         JNC     ??USCI_A1_ISR_2
     90                IOTRead = INITIAL;         // Reset Index
   \   000042   8243....     MOV.W   #0x0, &IOTRead
     91              }
     92              break;
     93            case SW_SEL_4:		// Vector 4 - TXIFG
     94              // Code for Transmit
     95              break;
     96            default: break;
     97            }
     98          
     99          }
   \                     ??USCI_A1_ISR_2:
   \   000046   1E17         POPM.W  #0x2, R15
   \   000048   0013         RETI
   \   00004A                REQUIRE _A_UCA1RXBUF_L
   \   00004A                REQUIRE UCA1IV

   \                                 In  segment INTVEC, offset 0x56, root
   \                     `??USCI_A1_ISR::??INTVEC 86`:
   \   000056   ....         DC16    USCI_A1_ISR

   \                                 In  segment INTVEC, offset 0x60, root
   \                     `??USCI_A0_ISR::??INTVEC 96`:
   \   000060   ....         DC16    USCI_A0_ISR

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      8   USCI_A0_ISR
      8   USCI_A1_ISR


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       2  UCA0IV
       2  UCA1IV
      60  USCI_A0_ISR
       2  USCI_A0_ISR::??INTVEC 96
      74  USCI_A1_ISR
       2  USCI_A1_ISR::??INTVEC 86
       2  _A_UCA0RXBUF_L
       2  _A_UCA1RXBUF_L

 
   8 bytes in segment DATA16_AN
   4 bytes in segment INTVEC
 134 bytes in segment ISR_CODE
 
 134 bytes of CODE  memory
   0 bytes of CONST memory (+ 4 bytes shared)
   0 bytes of DATA  memory (+ 8 bytes shared)

Errors: none
Warnings: none
