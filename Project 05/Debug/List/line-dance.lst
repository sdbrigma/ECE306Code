###############################################################################
#
# IAR C/C++ Compiler V6.30.2.940/W32 for MSP430           21/Oct/2015  02:26:02
# Copyright 1996-2015 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for Texas Instruments MSP430, 8K KickStart Edition 6.30
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  
#        \\vmware-host\Shared Folders\Desktop\ECE306Code\Project
#        05\line-dance.c
#    Command line  =  
#        "\\vmware-host\Shared Folders\Desktop\ECE306Code\Project
#        05\line-dance.c" -lC "\\vmware-host\Shared
#        Folders\Desktop\ECE306Code\Project 05\Debug\List\" -o
#        "\\vmware-host\Shared Folders\Desktop\ECE306Code\Project
#        05\Debug\Obj\" --no_cse --no_unroll --no_inline --no_code_motion
#        --no_tbaa --debug -D__MSP430FR5739__ -e --double=32 --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\430\lib\dlib\dl430xlsfn.h" --core=430X --data_model=small -On
#        --multiplier=32 --hw_workaround=CPU40 --code_model=large
#    List file     =  
#        \\vmware-host\Shared Folders\Desktop\ECE306Code\Project
#        05\Debug\List\line-dance.lst
#    Object file   =  
#        \\vmware-host\Shared Folders\Desktop\ECE306Code\Project
#        05\Debug\Obj\line-dance.r43
#
###############################################################################

\\vmware-host\Shared Folders\Desktop\ECE306Code\Project 05\line-dance.c
      1          /*******************************************************************************
      2          *        Author: Steffon Brigman
      3          *        Date:   October 2015
      4          *        Description: This file contains code that runs motor with ADC values
      5          *        Built with IAR Embedded Workbench Version: V7.0.5/W32 (6.10.5)
      6          *
      7          *        File name: line-dance.c
      8          *        Passed : No variables passed 
      9          *        Locals: No locals variables
     10          *        Returned: no values returned 
     11          *        Globlas: No variables used
     12          *******************************************************************************/
     13          
     14          // Includes
     15          #include  "macros.h"
     16          #include  "msp430.h"

   \                                 In  segment DATA16_AN, at 0x202
   \   union <unnamed> _A_PAOUT_L
   \                     _A_PAOUT_L:
   \   000000                DS8 2
     17          #include  "functions.h"
     18          extern char *display_1;
     19          extern char *display_2;
     20          extern char *display_3;
     21          extern char *display_4;
     22          extern char posL1;
     23          extern char posL2;
     24          extern char posL3;
     25          extern char posL4;
     26          extern unsigned int ADC_Right_Detector;
     27          extern unsigned int ADC_thumb;
     28          extern unsigned int ADC_Left_Detector;
     29          extern unsigned int tracking_value_high;
     30          extern unsigned int tracking_value_low;
     31          extern unsigned int tracking_value;
     32          extern unsigned int ambience;
     33          
     34          

   \                                 In  segment CODE, align 2
     35          void line_dance(void){
   \                     line_dance:
   \   000000   1B15         PUSHM.W #0x2, R11
     36            emitter_on();
   \   000002   ........     CALLA   #emitter_on
     37              display_1 = "==========";
   \   000006   B240........ MOV.W   #`?<Constant "==========">`, &display_1
     38              posL1 = ZERO;
   \   00000C   C243....     MOV.B   #0x0, &posL1
     39              display_2 = "FORWARD";
   \   000010   B240........ MOV.W   #`?<Constant "FORWARD">`, &display_2
     40              posL2 = 2;
   \   000016   E243....     MOV.B   #0x2, &posL2
     41              display_3 = "==========";
   \   00001A   B240........ MOV.W   #`?<Constant "==========">`, &display_3
     42              posL3 = ZERO;
   \   000020   C243....     MOV.B   #0x0, &posL3
     43              display_4 = "          ";
   \   000024   B240........ MOV.W   #`?<Constant "          ">`, &display_4
     44              posL4 = ZERO;
   \   00002A   C243....     MOV.B   #0x0, &posL4
     45              Display_Process();
   \   00002E   ........     CALLA   #Display_Process
     46          
     47            while(ALWAYS){// loop to travel straight
     48              // read left and right detectors
     49              /*if(ADC_Left_Detector>tracking_value_high){
     50                Five_msec_Delay(25); // pause for quarter of a second
     51                break;
     52              }*/
     53              ADC_Process();
   \                     ??line_dance_0:
   \   000032   ........     CALLA   #ADC_Process
     54              motor_straight();
   \   000036   ........     CALLA   #motor_straight
     55              ADC_Process();
   \   00003A   ........     CALLA   #ADC_Process
     56              if((ADC_Right_Detector>tracking_value_high)||(ADC_Left_Detector>tracking_value_high)){
   \   00003E   9292........ CMP.W   &ADC_Right_Detector, &tracking_value_high
   \   000044   0428         JNC     ??line_dance_5
   \   000046   9292........ CMP.W   &ADC_Left_Detector, &tracking_value_high
   \   00004C   F22F         JC      ??line_dance_0
     57                Five_msec_Delay(25); // pause for quarter of a second
   \                     ??line_dance_5:
   \   00004E   3C401900     MOV.W   #0x19, R12
   \   000052   ........     CALLA   #Five_msec_Delay
     58                break;
     59              }    
     60            }
     61            
     62            display_1 = "==========";
   \   000056   B240........ MOV.W   #`?<Constant "==========">`, &display_1
     63              posL1 = ZERO;
   \   00005C   C243....     MOV.B   #0x0, &posL1
     64              display_2 = "REVERSE";
   \   000060   B240........ MOV.W   #`?<Constant "REVERSE">`, &display_2
     65              posL2 = 2;
   \   000066   E243....     MOV.B   #0x2, &posL2
     66              display_3 = "==========";
   \   00006A   B240........ MOV.W   #`?<Constant "==========">`, &display_3
     67              posL3 = ZERO;
   \   000070   C243....     MOV.B   #0x0, &posL3
     68              display_4 = "          ";
   \   000074   B240........ MOV.W   #`?<Constant "          ">`, &display_4
     69              posL4 = ZERO;
   \   00007A   C243....     MOV.B   #0x0, &posL4
     70              Display_Process();
   \   00007E   ........     CALLA   #Display_Process
     71          
     72            
     73              unsigned int i = 0; // counter for time taken to reverse
   \   000082   0A43         MOV.W   #0x0, R10
     74              //ISR_COUNT = ZERO;
     75            while(ALWAYS){// loop to travel in reverse
     76              // give motors enough time to get away from black line
     77              if(i == 0){
   \                     ??line_dance_1:
   \   000084   0A93         CMP.W   #0x0, R10
   \   000086   0520         JNE     ??line_dance_6
     78                  motor_reverse(50);
   \   000088   3C403200     MOV.W   #0x32, R12
   \   00008C   ........     CALLA   #motor_reverse
     79                  i++;
   \   000090   1A53         ADD.W   #0x1, R10
     80              }
     81              i++;
   \                     ??line_dance_6:
   \   000092   1A53         ADD.W   #0x1, R10
     82              // MOTORS IN REVERSE
     83              ADC_Process();
   \   000094   ........     CALLA   #ADC_Process
     84              r_reverse_on();
   \   000098   ........     CALLA   #r_reverse_on
     85              l_reverse_on();
   \   00009C   ........     CALLA   #l_reverse_on
     86              ADC_Process();
   \   0000A0   ........     CALLA   #ADC_Process
     87              if((ADC_Right_Detector>(tracking_value_high*2)) || (ADC_Left_Detector>(tracking_value_high*2))){
   \   0000A4   1F42....     MOV.W   &tracking_value_high, R15
   \   0000A8   0F5F         RLA.W   R15
   \   0000AA   1F92....     CMP.W   &ADC_Right_Detector, R15
   \   0000AE   0628         JNC     ??line_dance_7
   \   0000B0   1F42....     MOV.W   &tracking_value_high, R15
   \   0000B4   0F5F         RLA.W   R15
   \   0000B6   1F92....     CMP.W   &ADC_Left_Detector, R15
   \   0000BA   E42F         JC      ??line_dance_1
     88                l_reverse_off();
   \                     ??line_dance_7:
   \   0000BC   ........     CALLA   #l_reverse_off
     89                r_reverse_off();
   \   0000C0   ........     CALLA   #r_reverse_off
     90                Five_msec_Delay(25); // pause for quarter of a second
   \   0000C4   3C401900     MOV.W   #0x19, R12
   \   0000C8   ........     CALLA   #Five_msec_Delay
     91                break;
     92              }
     93            }
     94            ISR_COUNT = ZERO;
   \   0000CC   8243....     MOV.W   #0x0, &ISR_COUNT
     95            emitter_off();
   \   0000D0   ........     CALLA   #emitter_off
     96            display_1 = "==========";
   \   0000D4   B240........ MOV.W   #`?<Constant "==========">`, &display_1
     97              posL1 = ZERO;
   \   0000DA   C243....     MOV.B   #0x0, &posL1
     98              display_2 = "FORWARD";
   \   0000DE   B240........ MOV.W   #`?<Constant "FORWARD">`, &display_2
     99              posL2 = 2;
   \   0000E4   E243....     MOV.B   #0x2, &posL2
    100              display_3 = "==========";
   \   0000E8   B240........ MOV.W   #`?<Constant "==========">`, &display_3
    101              posL3 = ZERO;
   \   0000EE   C243....     MOV.B   #0x0, &posL3
    102              display_4 = "          ";
   \   0000F2   B240........ MOV.W   #`?<Constant "          ">`, &display_4
    103              posL4 = ZERO;
   \   0000F8   C243....     MOV.B   #0x0, &posL4
    104              Display_Process();
   \   0000FC   ........     CALLA   #Display_Process
    105            
    106            i = i / 756;
   \   000100   0C4A         MOV.W   R10, R12
   \   000102   3E40F402     MOV.W   #0x2f4, R14
   \   000106   ........     CALLA   #?DivMod16u
   \   00010A   0A4C         MOV.W   R12, R10
    107            unsigned int a = ZERO;
   \   00010C   0B43         MOV.W   #0x0, R11
    108            while(a<i){
   \                     ??line_dance_2:
   \   00010E   0B9A         CMP.W   R10, R11
   \   000110   042C         JC      ??line_dance_8
    109              motor_straight();
   \   000112   ........     CALLA   #motor_straight
    110              a++;
   \   000116   1B53         ADD.W   #0x1, R11
   \   000118   FA3F         JMP     ??line_dance_2
    111            }
    112            Five_msec_Delay(25);
   \                     ??line_dance_8:
   \   00011A   3C401900     MOV.W   #0x19, R12
   \   00011E   ........     CALLA   #Five_msec_Delay
    113            
    114            display_1 = "==========";
   \   000122   B240........ MOV.W   #`?<Constant "==========">`, &display_1
    115              posL1 = ZERO;
   \   000128   C243....     MOV.B   #0x0, &posL1
    116              display_2 = "CLOCKWISE";
   \   00012C   B240........ MOV.W   #`?<Constant "CLOCKWISE">`, &display_2
    117              posL2 = ZERO;
   \   000132   C243....     MOV.B   #0x0, &posL2
    118              display_3 = "==========";
   \   000136   B240........ MOV.W   #`?<Constant "==========">`, &display_3
    119              posL3 = ZERO;
   \   00013C   C243....     MOV.B   #0x0, &posL3
    120              display_4 = "          ";
   \   000140   B240........ MOV.W   #`?<Constant "          ">`, &display_4
    121              posL4 = ZERO;
   \   000146   C243....     MOV.B   #0x0, &posL4
    122              Display_Process();
   \   00014A   ........     CALLA   #Display_Process
    123            
    124            // CW Circle
    125            while(ISR_COUNT<225){
   \                     ??line_dance_3:
   \   00014E   B290E100.... CMP.W   #0xe1, &ISR_COUNT
   \   000154   0534         JGE     ??line_dance_9
    126              left_on();
   \   000156   ........     CALLA   #left_on
    127              r_reverse_on();
   \   00015A   ........     CALLA   #r_reverse_on
   \   00015E   F73F         JMP     ??line_dance_3
    128            }
    129            left_off();
   \                     ??line_dance_9:
   \   000160   ........     CALLA   #left_off
    130            r_reverse_off();
   \   000164   ........     CALLA   #r_reverse_off
    131            ISR_COUNT = ZERO;
   \   000168   8243....     MOV.W   #0x0, &ISR_COUNT
    132            
    133            display_1 = "==========";
   \   00016C   B240........ MOV.W   #`?<Constant "==========">`, &display_1
    134              posL1 = ZERO;
   \   000172   C243....     MOV.B   #0x0, &posL1
    135              display_2 = "COUNTER";
   \   000176   B240........ MOV.W   #`?<Constant "COUNTER">`, &display_2
    136              posL2 = ZERO;
   \   00017C   C243....     MOV.B   #0x0, &posL2
    137              display_3 = "CLOCKWISE";
   \   000180   B240........ MOV.W   #`?<Constant "CLOCKWISE">`, &display_3
    138              posL3 = ZERO;
   \   000186   C243....     MOV.B   #0x0, &posL3
    139              display_4 = "==========";
   \   00018A   B240........ MOV.W   #`?<Constant "==========">`, &display_4
    140              posL4 = ZERO;
   \   000190   C243....     MOV.B   #0x0, &posL4
    141              Display_Process();
   \   000194   ........     CALLA   #Display_Process
    142            
    143            // CCW Circle
    144            while(ISR_COUNT<225){
   \                     ??line_dance_4:
   \   000198   B290E100.... CMP.W   #0xe1, &ISR_COUNT
   \   00019E   0534         JGE     ??line_dance_10
    145              right_on();
   \   0001A0   ........     CALLA   #right_on
    146              l_reverse_on();
   \   0001A4   ........     CALLA   #l_reverse_on
   \   0001A8   F73F         JMP     ??line_dance_4
    147            }
    148            right_off();
   \                     ??line_dance_10:
   \   0001AA   ........     CALLA   #right_off
    149            l_reverse_off();
   \   0001AE   ........     CALLA   #l_reverse_off
    150            ISR_COUNT = ZERO;
   \   0001B2   8243....     MOV.W   #0x0, &ISR_COUNT
    151            
    152              display_1 = "==========";
   \   0001B6   B240........ MOV.W   #`?<Constant "==========">`, &display_1
    153              posL1 = ZERO;
   \   0001BC   C243....     MOV.B   #0x0, &posL1
    154              display_2 = "==========";
   \   0001C0   B240........ MOV.W   #`?<Constant "==========">`, &display_2
    155              posL2 = ZERO;
   \   0001C6   C243....     MOV.B   #0x0, &posL2
    156              display_3 = "DONE!!!";
   \   0001CA   B240........ MOV.W   #`?<Constant "DONE!!!">`, &display_3
    157              posL3 = 2;
   \   0001D0   E243....     MOV.B   #0x2, &posL3
    158              display_4 = "==========";
   \   0001D4   B240........ MOV.W   #`?<Constant "==========">`, &display_4
    159              posL4 = ZERO;
   \   0001DA   C243....     MOV.B   #0x0, &posL4
    160              Display_Process();
   \   0001DE   ........     CALLA   #Display_Process
    161          }
   \   0001E2   1A17         POPM.W  #0x2, R11
   \   0001E4   1001         RETA
    162          

   \                                 In  segment CODE, align 2
    163          void emitter_on(void){
   \                     emitter_on:
    164            P1OUT |= IR_LED;
   \   000000   E2D20202     BIS.B   #0x4, &0x202
    165          }
   \   000004   1001         RETA
   \   000006                REQUIRE _A_PAOUT_L
    166          

   \                                 In  segment CODE, align 2
    167          void emitter_off(void){
   \                     emitter_off:
    168            P1OUT &= ~IR_LED;
   \   000000   E2C20202     BIC.B   #0x4, &0x202
    169          }
   \   000004   1001         RETA
   \   000006                REQUIRE _A_PAOUT_L
    170          

   \                                 In  segment CODE, align 2
    171          void calibrate_detector(void){
   \                     calibrate_detector:
    172            display_1 = "==========";
   \   000000   B240........ MOV.W   #`?<Constant "==========">`, &display_1
    173            posL1 = ZERO;
   \   000006   C243....     MOV.B   #0x0, &posL1
    174            display_2 = "CALIBRATE";
   \   00000A   B240........ MOV.W   #`?<Constant "CALIBRATE">`, &display_2
    175            posL2 = ZERO;
   \   000010   C243....     MOV.B   #0x0, &posL2
    176            display_3 = "DETECTORS";
   \   000014   B240........ MOV.W   #`?<Constant "DETECTORS">`, &display_3
    177            posL3 = ZERO;
   \   00001A   C243....     MOV.B   #0x0, &posL3
    178            display_4 = "==========";
   \   00001E   B240........ MOV.W   #`?<Constant "==========">`, &display_4
    179            posL4 = ZERO;
   \   000024   C243....     MOV.B   #0x0, &posL4
    180            Display_Process();
   \   000028   ........     CALLA   #Display_Process
    181            ISR_COUNT = ZERO;
   \   00002C   8243....     MOV.W   #0x0, &ISR_COUNT
    182            while(ISR_COUNT<100){
   \                     ??calibrate_detector_0:
   \   000030   B2906400.... CMP.W   #0x64, &ISR_COUNT
   \   000036   0A34         JGE     ??calibrate_detector_2
    183              ADC_Process();
   \   000038   ........     CALLA   #ADC_Process
    184              ambience = (ADC_Right_Detector + ADC_Left_Detector) / 2;
   \   00003C   1F42....     MOV.W   &ADC_Right_Detector, R15
   \   000040   1F52....     ADD.W   &ADC_Left_Detector, R15
   \   000044   5F03         RRUM.W  #0x1, R15
   \   000046   824F....     MOV.W   R15, &ambience
   \   00004A   F23F         JMP     ??calibrate_detector_0
    185            }
    186            ISR_COUNT = ZERO;
   \                     ??calibrate_detector_2:
   \   00004C   8243....     MOV.W   #0x0, &ISR_COUNT
    187            ambience = ADC_RESOLUTION - ambience; // ambience correction factor
   \   000050   3F400004     MOV.W   #0x400, R15
   \   000054   1F82....     SUB.W   &ambience, R15
   \   000058   824F....     MOV.W   R15, &ambience
    188            ambience = ambience * 2;
   \   00005C   1F42....     MOV.W   &ambience, R15
   \   000060   0F5F         RLA.W   R15
   \   000062   824F....     MOV.W   R15, &ambience
    189              
    190            emitter_on();
   \   000066   ........     CALLA   #emitter_on
    191            while(ISR_COUNT < 100){
   \                     ??calibrate_detector_1:
   \   00006A   B2906400.... CMP.W   #0x64, &ISR_COUNT
   \   000070   0A34         JGE     ??calibrate_detector_3
    192              ADC_Process();
   \   000072   ........     CALLA   #ADC_Process
    193              tracking_value = (ADC_Right_Detector + ADC_Left_Detector) / 2;
   \   000076   1F42....     MOV.W   &ADC_Right_Detector, R15
   \   00007A   1F52....     ADD.W   &ADC_Left_Detector, R15
   \   00007E   5F03         RRUM.W  #0x1, R15
   \   000080   824F....     MOV.W   R15, &tracking_value
   \   000084   F23F         JMP     ??calibrate_detector_1
    194            }
    195            ISR_COUNT = ZERO;
   \                     ??calibrate_detector_3:
   \   000086   8243....     MOV.W   #0x0, &ISR_COUNT
    196            tracking_value_high = tracking_value + ambience;
   \   00008A   1F42....     MOV.W   &tracking_value, R15
   \   00008E   1F52....     ADD.W   &ambience, R15
   \   000092   824F....     MOV.W   R15, &tracking_value_high
    197            tracking_value_low = tracking_value - ambience;
   \   000096   1F42....     MOV.W   &tracking_value, R15
   \   00009A   1F82....     SUB.W   &ambience, R15
   \   00009E   824F....     MOV.W   R15, &tracking_value_low
    198            emitter_off();  
   \   0000A2   ........     BRA     #emitter_off
    199          }

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "==========">`:
   \   000000   3D3D3D3D3D3D DC8 "=========="
   \            3D3D3D3D00  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "FORWARD">`:
   \   000000   464F52574152 DC8 "FORWARD"
   \            4400        

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "          ">`:
   \   000000   202020202020 DC8 "          "
   \            2020202000  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "REVERSE">`:
   \   000000   524556455253 DC8 "REVERSE"
   \            4500        

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "CLOCKWISE">`:
   \   000000   434C4F434B57 DC8 "CLOCKWISE"
   \            49534500    

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "COUNTER">`:
   \   000000   434F554E5445 DC8 "COUNTER"
   \            5200        

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "DONE!!!">`:
   \   000000   444F4E452121 DC8 "DONE!!!"
   \            2100        

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "CALIBRATE">`:
   \   000000   43414C494252 DC8 "CALIBRATE"
   \            41544500    

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "DETECTORS">`:
   \   000000   444554454354 DC8 "DETECTORS"
   \            4F525300    

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      4   calibrate_detector
        4   -> ADC_Process
        4   -> Display_Process
        0   -> emitter_off
        4   -> emitter_on
      4   emitter_off
      4   emitter_on
      8   line_dance
        8   -> ADC_Process
        8   -> Display_Process
        8   -> Five_msec_Delay
        8   -> emitter_off
        8   -> emitter_on
        8   -> l_reverse_off
        8   -> l_reverse_on
        8   -> left_off
        8   -> left_on
        8   -> motor_reverse
        8   -> motor_straight
        8   -> r_reverse_off
        8   -> r_reverse_on
        8   -> right_off
        8   -> right_on
        8 ?DivMod16u


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      11  ?<Constant "          ">
      11  ?<Constant "==========">
      10  ?<Constant "CALIBRATE">
      10  ?<Constant "CLOCKWISE">
       8  ?<Constant "COUNTER">
      10  ?<Constant "DETECTORS">
       8  ?<Constant "DONE!!!">
       8  ?<Constant "FORWARD">
       8  ?<Constant "REVERSE">
       2  _A_PAOUT_L
     166  calibrate_detector
       6  emitter_off
       6  emitter_on
     486  line_dance

 
 664 bytes in segment CODE
   2 bytes in segment DATA16_AN
  84 bytes in segment DATA16_C
 
 664 bytes of CODE  memory
  84 bytes of CONST memory
   0 bytes of DATA  memory (+ 2 bytes shared)

Errors: none
Warnings: none
